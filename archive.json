{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2022-03-31T00:06:10.382024+00:00",
  "repo": "cjpatton/vdaf",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 8,
      "id": "I_kwDOGKuqOc4-qH_-",
      "title": "Syntax: Use agg parameter for prepare-init only",
      "url": "https://github.com/cjpatton/vdaf/issues/8",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This aggregation parameter isn't used anywhere but during the preparation phase. We may wind up wanting to specify a scheme that needs this, at which point we can add this back in. For now, removing this unnecessary joint will simplify the syntax.",
      "createdAt": "2021-11-11T18:01:23Z",
      "updatedAt": "2021-12-28T17:43:25Z",
      "closedAt": "2021-12-28T17:43:25Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "The aggregation parameter is used in hits in order to decode output shares and aggregate shares. Upon further reflection, it seems like we'll need something like this going forward.",
          "createdAt": "2021-12-28T17:43:25Z",
          "updatedAt": "2021-12-28T17:43:25Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOGKuqOc4-qq61",
      "title": "Can / should VDAF support DP shufflers?",
      "url": "https://github.com/cjpatton/vdaf/issues/9",
      "state": "OPEN",
      "author": "csharrison",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Shuffle differential privacy (https://arxiv.org/pdf/1811.12469.pdf and many other papers) is a type of differential privacy where the privacy mechanism can be thought of as a composition of two pieces:\r\n1. A local randomizer applying some local noise to data (and stripping identifiers, etc)\r\n2. A central curator that takes as input a batch of client data and simply applies a permutation on it\r\n\r\nThe power of the shuffle DP is that the server-side mechanism is _simple_ and _general purpose_. The exact same shuffler can be used for different applications measuring different kinds of things. Privacy guarantees are based on two things:\r\n\r\n1. The level of local noise added to the data\r\n2. The number of clients that participate in a shuffle\r\n\r\nAt an intuitive level, the more reports you have, and the more noise is injected into the reports, the more a given client's input is \"hidden in the crowd\".\r\n\r\nIs this a good fit for VDAFs? Shuffling is conceptually a very simple task to ask a 2-party MPC protocol to do. I could imagine slotting this into the VDAF structure like:\r\n\r\n- Clients split their local data D into \"shares\" where Helper 1 gets Enc2(D) and Helper 2 gets Enc1(null). (Which helper gets the real message can be randomized). Note that nested encryption is used so that no helper can see any raw data before it is shuffled.\r\n- When each helper gets its batch of data, it will run it through a shuffle step, and send the shuffle results to the other helper\r\n- After the exchange, the helpers shuffle the exchanged batches one more time (ensuring all data is shuffled twice, once by each helper).\r\n- Helpers can then decrypt the data and share each shuffled batch to the collector\r\n\r\nPossible concerns:\r\n\r\n- In the simple example above, helpers learn a shuffled version of the true data (i.e. a DP release). The protocol is not zero-knowledge. This could probably be fixed, there is no need for helpers to learn any raw data.\r\n- We rely exclusively on DP for the protection. Whether this can be called \"aggregation\" is maybe subject for debate. Certainly you can say that (if the batches are large enough, with enough noise), that no individual's data can be learned\r\n- The splitting of shares and helpers independently shuffling partial batches is a bit awkward. Probably the ideal mechanism would be for clients to send all data to Helper 1, which shuffles and sends to Helper 2, which sends data to the collector. Parallel shuffling buys us nothing.\r\n- Some shuffle protocols may want some kind of \"label\" in the clear, with minimum batch sizes per label.\r\n\r\nAnyways, thoughts appreciated! Shuffling can be a simple and effective way to achieve good privacy with very simple mechanisms, but it doesn't fit so well into VDAFs.\r\n\r\ncc @schoppmp ",
      "createdAt": "2021-11-11T21:24:52Z",
      "updatedAt": "2021-11-16T18:36:01Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "Interesting idea! This does indeed sound like a practical way to get good privacy. Even without DP, you get unlinkability of measurements to the client that sent them. This is basically what a mixnet does.\r\n\r\n* From a syntax perspective, this kind of construction doesn't fit because it requires the aggregation phase to be interactive. Currently the VDAF syntax permits interaction only during the preparation phase. More to the point, shuffling requires `O(n)` space to compute the aggregate result, where `n` is the number of measurements. On the other hand, evaluating the prio3 or hits VDAF requires just `O(1)` space.\r\n* From a security perspective, unlinkability of measurements to senders is useful, but is weaker than what we hope to achieve for, say, prio3 or hits, which is that they learn only the aggregate result. Perhaps there's a way to patch the scheme to prevent leaking the set of measurements, as you suggest. But suppose we manage to ensure that all the aggregators learn is the aggregate result: then what does shuffling buy us?\r\n* Broadening our perspective a bit, consider that VDAFs are *special purpose*  in the sense that a particular VDAF is only suitable for as particular (class of) aggregation functions. On the other hand, the shuffling scheme you're proposing is *general purpose*: pretty much any aggregation function can be computed this way, you just need to be able to define a \"null\" input. I think the purpose of this document should be to standardize an interface between general purpose \"wrapper\" protocols, like PPM, to special purpose schemes that are all ensure some baseline notion of security.\r\n\r\nMy own conclusion is that this protocol shape isn't appropriate for the VDAF document, however this may well be in-scope for what the PPM working group does.\r\n\r\nWhat do you think @bifurcation?",
          "createdAt": "2021-11-15T17:55:34Z",
          "updatedAt": "2021-11-15T17:55:34Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "By the way, I'm reading https://eprint.iacr.org/2021/1490.pdf right now. This protocol seems to have some shuffling, but also seems to aim for a security property stronger than unlinkability. I think if we can achieve the same security for this protocol as for prio3/hits, I think it's worth considering including it here.",
          "createdAt": "2021-11-15T19:42:22Z",
          "updatedAt": "2021-11-15T19:42:22Z"
        },
        {
          "author": "csharrison",
          "authorAssociation": "NONE",
          "body": "Thanks @cjpatton , this makes sense to me. A few quick responses below:\r\n\r\n> From a security perspective, unlinkability of measurements to senders is useful, but is weaker than what we hope to achieve for, say, prio3 or hits, which is that they learn only the aggregate result. Perhaps there's a way to patch the scheme to prevent leaking the set of measurements, as you suggest. But suppose we manage to ensure that all the aggregators learn is the aggregate result: then what does shuffling buy us?\r\n\r\nOne thing shuffling buys you is flexibility. Let's say all my users input data in [0, 10]. You could imagine a couple of different ways of aggregating this data, e.g. reporting the sum, median, percentiles, etc. With a shuffled version of the data, you can compute all of these on the collector side without embedding the computations in the aggregators.\r\n\r\nThere is also flexibility in terms of data used. In principle (as long as you trust the clients), the aggregators can just be shuffling opaque bytes. Clients could update to submit different kinds of data without any behavior update needed on the aggregator side. For instance, rather than shuffling integers they could shuffle sketches or some other data structure.\r\n\r\n> By the way, I'm reading https://eprint.iacr.org/2021/1490.pdf right now. This protocol seems to have some shuffling, but also seems to aim for a security property stronger than unlinkability. I think if we can achieve the same security for this protocol as for prio3/hits, I think it's worth considering including it here.\r\n\r\nThis proposal is interesting but it isn't the same kind of general purpose shuffling I'm discussing here. That paper only discusses computing histograms.",
          "createdAt": "2021-11-15T20:27:02Z",
          "updatedAt": "2021-11-15T20:27:02Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "I agree the flexibility is attractive. My point about shuffling alone doesn't prevent aggregators from learning the set of measurements. Indeed, this is what makes it so flexible!",
          "createdAt": "2021-11-15T21:30:45Z",
          "updatedAt": "2021-11-15T21:30:45Z"
        },
        {
          "author": "csharrison",
          "authorAssociation": "NONE",
          "body": "> I agree the flexibility is attractive. My point about shuffling alone doesn't prevent aggregators from learning the set of measurements. Indeed, this is what makes it so flexible!\r\n\r\nOh sorry I missed this point. It should be easy to ensure that the shuffled data is not visible to the aggregators if they don't collude with the collector - just ensure all the data is also encrypted to the collector's key. The requirement is just that the MPC shuffles opaque blobs.",
          "createdAt": "2021-11-15T21:58:47Z",
          "updatedAt": "2021-11-15T21:58:47Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "Right, but the collector would see the set of measurements in the clear, right? All the aggregators have done is permuted them.",
          "createdAt": "2021-11-15T22:18:58Z",
          "updatedAt": "2021-11-15T22:18:58Z"
        },
        {
          "author": "csharrison",
          "authorAssociation": "NONE",
          "body": "The collector sees the set of measurements \"in the clear\", but the technique is designed to be combined with local noise so it isn't really accurate to say that the final release contains the all of the original measurements.\r\n\r\n",
          "createdAt": "2021-11-16T18:29:12Z",
          "updatedAt": "2021-11-16T18:29:12Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "Yes, true enough!",
          "createdAt": "2021-11-16T18:36:01Z",
          "updatedAt": "2021-11-16T18:36:01Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOGKuqOc4-1Uh5",
      "title": "Is Masked LARk a (V)DAF?",
      "url": "https://github.com/cjpatton/vdaf/issues/10",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "[This paper](https://arxiv.org/pdf/2110.14794.pdf) describes a distributed computation of a gradient descent. We're given a set of `(x[i], y[i])` pairs, where `x[i]` is client `i`'s *feature* and `y[i]` is the corresponding *label*. From skimming the paper, my understanding is that stochastic gradient descent is computed iteratively as\r\n```\r\n\\theta_{j+1} = \\theta_j - \\eta * (f(x[1], y[1], \\theta_j) + ... + f(x[n], y[n], \\theta_j))\r\n```\r\nuntil we find a (locally) optimal model `\\theta_j`.  for a particular function `f`. (`\\eta` is a constant called the \"learning rate\".) What the paper shows is that each iteration can be computed by two aggregators who hold the plaintext features `x[1], ..., x[n]`, but only secret shares of the labels `y[1], ..., y[n]`. The features are kept privacy by adding DP.\r\n\r\nThis looks an awful lot like a distributed aggregation function:\r\n* measurement is a feature and label\r\n* aggregation parameter is the model `\\theta_j` from the previous step.\r\n* aggregate result is the model `\\theta_{j+1}` for the next step.\r\n\r\nAnd yet there are two important differences:\r\n1. The label is secret shared, but the feature is not. We can certainly formalize security in the usual way --- the aggregators learn nothing about the measurements beyond what they can deduce from their view of the protocol. But this definition isn't all that meaningful if the feature leaks a lot of information about the label.\r\n2. The output isn't verifiable. In particular, the current protocol appears to allow a client to submit bogus input shares and garble the output without being detected.\r\n\r\nAdding verifiability (i.e., solving (2)) seems quite feasible. I'm not sure how best to address (1). It might be worth reaching out to the papers' authors to see if they considered how they might keep the features secret.\r\n\r\n@csharrison I'm curious if you have thoughts here.",
      "createdAt": "2021-11-15T22:17:30Z",
      "updatedAt": "2021-11-15T22:17:30Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 11,
      "id": "I_kwDOGKuqOc4-5xna",
      "title": "Syntax: Public preprocessing during the preparation phase",
      "url": "https://github.com/cjpatton/vdaf/issues/11",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "For both prio3 and hits, each round of the preparation phase consists of a step of \"preprocessing\" of the previous round's messages. This preprocessing step is identical for all of the aggregators. In hits, for example, each aggregator begins each round by summing up the messages from the previous round. From Figure 15 in https://cjpatton.github.io/vdaf/draft-patton-cfrg-vdaf.html#name-preparation-3:\r\n```\r\n    ...\r\n    elif self.step == \"sketch round 1\" and len(inbound) == 2:\r\n      verifier_1 = Field[l].deocde_vec(inbound[0]) + \\             # ADD UP INPUT MESSAGES\r\n                   Field[l].deocde_vec(inbound[1])\r\n\r\n      verifier_share_2 = [\r\n        (verifier_1[0] * verifier_1[0] \\\r\n         - verifier_1[1] \\\r\n         - verifier_1[2]) * self.party_id \\\r\n        + A_share * verifer_1[0] \\\r\n        + B_share\r\n      ]\r\n\r\n      self.step = \"sketch round 2\"\r\n      return Field[l].encode_vec(verifier_share_2)\r\n\r\n    elif self.step == \"sketch round 2\" and len(inbound) == 2:\r\n      verifier_2 = Field[l].decode_vec(inbound[0]) + \\             # ADD UP INPUT MESSAGES\r\n                   Field[l].decode_vec(inbound[1])\r\n\r\n      if verifier_2 != 0: raise ERR_INVALID\r\n      return Field[l].encode_vec(self.output_share)\r\n   ...\r\n```\r\nThe essence of what's happening here is that, in each round, the aggregators are exchanging additive shares of a single message. prio3 is similar, although each message consists of an XOR-share of as byte string and an additive share of the FLP verifier. From Figure 10:\r\n```\r\n   ...\r\n   elif self.step == \"waiting\" and len(inbound) == SHARES:\r\n      k_joint_rand = zeros(KEY_SIZE)\r\n      verifier = vec_zeros(VERIFIER_LEN)\r\n      for r_share in inbound:\r\n        (k_joint_rand_share,\r\n         verifier_share) = decode_verifier_share(r_share)\r\n\r\n        k_joint_rand ^= k_joint_rand_share                           # ADD UP xor SHARES\r\n        verifer += verifier_share                                    # ADD UP ADDITIVE SHARES\r\n\r\n      if k_joint_rand != self.k_joint_rand: raise ERR_INVALID\r\n      if not flp_decide(verifier): raise ERR_INVALID\r\n      return Field.encode_vec(self.output_share)\r\n   ...\r\n```\r\nWhat we're likely to do in the PPM protocol is have one aggregator -- the Leader -- collect the verifier messages at each round and relay them to the other aggregators. We could save on communication cost if we have the Leader perform this public preprocessing step itself and disseminate the result.\r\n\r\nTo make this optimization generic, I'd like to propose that we lift the public processing step to an explicit part of the syntax. In particular, we'd change the preparation phase as follows (from Figure 6):\r\n```\r\n   # Each aggregator initializes its preparation state.\r\n    prep_states = []\r\n    for j in range(SHARES):\r\n      prep_states.append(PrepState(\r\n          verify_params[j], agg_param, nonce, input_shares[j]))\r\n\r\n    # Aggregators recover their output shares.\r\n-   inbound = []\r\n+   inbound = \"\"\r\n    for i in range(ROUNDS+1):\r\n      outbound = []\r\n      for j in range(SHARES):\r\n        outbound.append(prep_states[j].next(inbound))\r\n      # This is where we would send messages over the network\r\n      # in a distributed VDAF computation.\r\n-     inbound = outbound\r\n+     inbound = prep_preprocess(j, outbound)\r\n\r\n    # The final outputs of validation are the output shares\r\n    # for this input.\r\n    output_shares.append(outbound)\r\n```\r\n\r\nI don't think this syntactic change would decrease generality, but I also don't want it to be a nuisance. Maybe it makes sense to not call this out explicitly?",
      "createdAt": "2021-11-16T21:12:25Z",
      "updatedAt": "2022-01-19T17:44:43Z",
      "closedAt": "2022-01-19T17:44:43Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I actually think this could *increase* generality, since we're adding a stage that transforms outbound shares to some inbound parameter.  In the current framing, that stage has to be the identity transformation, such that the inbound parameter is the set of outbound shares.\r\n\r\nThe only real trouble I see here is that we don't currently have a name for the actor who would perform this transformation.  And just to confirm -- is this actor really untrusted in the examples we have today?  Or are they trusted in some limited way?",
          "createdAt": "2021-11-17T16:03:32Z",
          "updatedAt": "2021-11-17T16:03:32Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "Who performs this transform will depend on how the VDAF is mapped to a protocol. It ought to be the case that *anyone* can perform this transform without impacting privacy. (We'll need to make this clear in security considerations.)",
          "createdAt": "2021-11-17T17:09:01Z",
          "updatedAt": "2021-11-17T17:09:01Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">What we're likely to do in the PPM protocol is have one aggregator -- the Leader -- collect the verifier messages at each round and relay them to the other aggregators. We could save on communication cost if we have the Leader perform this public preprocessing step itself and disseminate the result.\r\n\r\nI think this is a good optimization but IIUC it requires that the PPM leader be able to see all the verifier messages (i.e., Prio proof shares) in the clear, which isn't currently possible because the helper's proof share is inside the HPKE encrypted envelope. So does this change require corresponding PPM changes to move verifier shares out of the encryption envelope, or am I misunderstanding?",
          "createdAt": "2022-01-04T22:38:55Z",
          "updatedAt": "2022-01-04T22:38:55Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "What is being preprocessed is the set of messages passed between the Aggregators, which is not the proof shares. The proof shares are sent by the Clients to the Aggregators. If the Aggregators were to exchanges the proof shares themselves, this would result in a security violation.",
          "createdAt": "2022-01-04T23:06:11Z",
          "updatedAt": "2022-01-04T23:06:11Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The important thing is that this only reduces the complexity of communication if there are more than two aggregators, which is not currently the case in PPM. It's nevertheless a good change.",
          "createdAt": "2022-01-05T01:47:38Z",
          "updatedAt": "2022-01-05T01:47:38Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOGKuqOc4-98yb",
      "title": "VDAF for quantiles?",
      "url": "https://github.com/cjpatton/vdaf/issues/12",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "With `prio3` it's straightforward to roughly estimate quantiles using a histogram (cf https://docs.rs/prio/0.6.1/prio/vdaf/prio3/type.Prio3Histogram64.html). But what if you wanted to precisely compute, say, the 50th percentile (i.e., the median) or the 95th percentile? Prio isn't well-suited for this (cf [[CGB17], Appendix G]).\r\n\r\nIf your application allows for multiple rounds of interaction with the clients, maybe you could do a kind of binary search to find the quantile you're after. Suppose the client measurements are arbitrary 32-bit integers and you want to compute the median. Suppose there are `N` measurements in all. Let `buckets = [2^31]`. Have the clients shard their measurements using `buckets` as the bucket boundaries. Execute the VDAF over the set of input shares, getting bucket counts `agg` as the aggregate result. `agg[0]` is equal to the number of measurements less than or equal to `2^31`, and `agg[1] <= N/2`, then the median must be less than `2^31`. On the other hand, if `agg[1] > N/2` then you know the median must greater than `2^31`. You then repeat the process, adjusting the bucket boundaries based on the previous result: if the median is less than `2^31`, then let `buckets = [2^31 - 2^30]`; otherwise let `buckets = [2^31 + 2^30]`.\r\n\r\nI'm not sure how many iterations would be needed, or how precisely you could compute quantiles this way. Regardless, ideally there would be a VDAF that allows for computing quantiles without interacting with clients more than once.\r\n\r\n\r\n\r\n\r\n\r\n[CGB17]: https://crypto.stanford.edu/prio/paper.pdf",
      "createdAt": "2021-11-17T17:58:28Z",
      "updatedAt": "2021-11-17T17:58:28Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 13,
      "id": "I_kwDOGKuqOc4_1qX5",
      "title": "Specify method for generating field elements (was \"Proposal: use hash to field to generate field elements from a seed\")",
      "url": "https://github.com/cjpatton/vdaf/issues/13",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "> TODO This functionality closely resembles what people usually think of as an extract-then-expand KDF, but differs somewhat in its syntax and, also, its required security properties. Can we get the same functionality from something that's more commonplace? HKDF doesn't fit the bill, unfortunately, because keys can only be expanded to a fairly short length. Our application requires a rather long key stream.\r\n\r\nand\r\n>    *  Field.rand_vec(len: Unsigned) -> output: Vec[Field] returns a\r\n      vector of random field elements.  The length of output MUST be\r\n      len.\r\n>\r\n>         NOTE In reality this would be achieved by generating a random\r\n         key and expanding it into a sequence of field elements using a\r\n         key derivation scheme.  This should probably be made explicit.\r\n\r\n\r\nIn hash to curve draft, there is a method to derive an arbitrary number of field elements from a seed source.\r\nThis is called a Expander, and there are two types: one based on Merkle-Damgard functions and the other based on eXtendable Output functions.\r\nSee section 5.3 : https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve#section-5.3\r\n\r\n",
      "createdAt": "2021-12-03T22:53:51Z",
      "updatedAt": "2022-02-25T19:42:16Z",
      "closedAt": "2022-02-25T19:42:16Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "I definitely like the idea of reusing a functionality from an existing draft.",
          "createdAt": "2021-12-04T00:02:20Z",
          "updatedAt": "2021-12-04T00:02:20Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "Update based on discussion I had with @armfazh offline: We currently use rejection sampling for mapping bit strings to field elements. This has the advantage of inducing no bias, but it has the distinct disadvantage of making the runtime very slow for some fraction of the time. We hope that a constant-time algorithm will have better worst-case, or even average-case, performance. @armfazh is working on a performance evaluation.\r\n\r\nhash-to-field is quite simple: just take a hash function `H: \\bits^* \\to \\bits^n`, interpret the output as a `2^n`-bit integer, and reduce the integer mod `p`. The question is how much bias this modular reduction induces.\r\n\r\nOr more precisely: What's the statistical distance between a random variable chosen uniformly from `[0, p)` and a random variable chosen by sampling `[0, 2^n)` for some `2^n > p` and reducing the sampled number mod `p`? Intuitively, this depends on how large is `b = 2^n % p`: the smaller the `b`, the fewer outputs there are due to the modular reduction. In fact, it's not hard to show that the statistical distance can be bounded, fairly tightly, by `O(2^(log2(p) - n)`. This suggests that for `n \\approx 2*log(p)` the statistical distance is about `O(1/2^log(p))`.\r\n\r\nWhat does this mean for security? In our analysis of prio3 it'll be helpful to model the function that maps a seed to a sequence of field elements as a random oracle. Our hope would be that hash-to-field is indifferentiable from such an RO when the underlying hash function `H` is modeled as an RO. This ought to be the case for sufficiently large `n`.\r\n\r\nWe also observed that there are primes `p` for which there is an optimal `n`. For example, libprio uses `p = 18446744069414584321` for its 64-bit prime. It turns out that `2^192 % p == 1`, so picking `n=192` would make the distributions very close indeed. Ideally we could find a 128-bit prime with this property, too.",
          "createdAt": "2022-02-02T00:28:54Z",
          "updatedAt": "2022-02-02T00:28:54Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "@schoppmp made an excellent point, which we ought to take into account: hash_to_field appears to be designed for entropy extraction. (@armfazh can you confirm?). However for our application we don't need an entropy extractor because we're starting with a (pseuo)random seed. Thus using SHA-2 or SHAKE for instantiating hash_to_field would be overkill: AES in CTR-mode would suite our needs perfectly fine.",
          "createdAt": "2022-02-03T18:43:38Z",
          "updatedAt": "2022-02-03T18:43:38Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "NONE",
          "body": "Certainly, any SHA or SHAKE will be slower than AES (provided machine has hardware support for it). \r\nHash to field just receives seeds as input, and is not used for key expansion.",
          "createdAt": "2022-02-03T21:36:38Z",
          "updatedAt": "2022-02-03T21:36:38Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "Right, and given how much randomness we consume in our applications, I think it would be worthwhile providing a mapping a seed-to-field-vector expansion function that is based purely on AES. I'll put together a PR with a proposal.",
          "createdAt": "2022-02-04T17:05:54Z",
          "updatedAt": "2022-02-04T17:05:54Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "Ok, before sending a PR, I want to get y'all's take on the over all shape of the solution. Here's my proposal:\r\n1. Add a parameter `EXPANDED_SIZE` to `Field` that specifies the number of random bytes that are sampled per field element.\r\n2. Adopt a modified version of `hash_to_field` in which we replace `expand_message` with the key stream output by AES-CTR (or some other, compatible primitive).\r\n\r\nThis could look something like this (quoting from https://github.com/cjpatton/vdaf/pull/24):\r\n```python\r\n# The base class for PRGs.\r\nclass Prg:\r\n    # Size of the seed.\r\n    SEED_SIZE: int\r\n\r\n    # Derive a fresh seed from an existing `seed`. The `info` input is used for\r\n    # domain sepration.\r\n    @classmethod\r\n    def derive(cls, seed: bytes, info: bytes) -> bytes:\r\n        raise Error(\"not implemented\")\r\n\r\n    # Expand the input `seed` into the number of bytes requested.\r\n    @classmethod\r\n    def expand(cls, seed: bytes, length: int) -> bytes:\r\n        raise Error(\"not implemented\")\r\n\r\n    # Expand the input `seed` into vector of `length` field elements. This\r\n    # algorithm is based on \"hash_to_field\" in draft-irtf-cfrg-hash-to-curve13.\r\n    @classmethod\r\n    def expand_into_vec(cls, Field, seed: bytes, length: int):\r\n        L = Field.EXPANDED_SIZE\r\n        len_in_bytes = length * L\r\n        uniform_bytes = cls.expand(seed, len_in_bytes)\r\n\r\n        vec = []\r\n        for i in range(length):\r\n            tv = uniform_bytes[L*i:L*(i+1)]\r\n            u_i = OS2IP(tv) # Decode `tv` into an integer.\r\n            vec.append(Field(u_i))\r\n        return vec\r\n```\r\n\r\n@schoppmp what do you think of this proposal? Of course, we wouldn't literally plop down this Python into the spec :) A concrete PRG would implement `derive` and `expand`. For example:\r\n\r\n```python\r\n# A pseudorandom generator based on AES128. CMAC {{!RFC4493}} is used for seed\r\n# derivation and CTR mode is used for seed expansion.\r\nclass PrgAes128(Prg):\r\n    # Associated parameters\r\n    SEED_SIZE = 16\r\n\r\n    @classmethod\r\n    def derive(cls, seed, info) -> bytes:\r\n        hasher = CMAC.new(seed, ciphermod=AES)\r\n        return hasher.update(info).digest()\r\n\r\n    @classmethod\r\n    def expand(cls, seed, length):\r\n        counter = Counter.new(128, initial_value=bytes_to_long(zeros(16)))\r\n        cipher = AES.new(seed, AES.MODE_CTR, counter=counter)\r\n        # CTR-mode encryption of the all-zero string of the specified length and using\r\n        # the all-zero block as the IV.\r\n        cipher_stream = cipher.encrypt(zeros(length))\r\n        return cipher_stream\r\n```\r\n\r\nCMAC is a somewhat unconventional choice. A more conventional choice might be HMAC-SHA256, however in that case we might want to increase `SEED_SIZE` to `32`.",
          "createdAt": "2022-02-06T01:36:45Z",
          "updatedAt": "2022-02-06T01:57:22Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "PR #25 addresses the issue raised here. I ended up going in a slightly different direction with the API:\r\n```python\r\nclass Prg:\r\n    # Size of the seed.\r\n    SEED_SIZE: int\r\n\r\n    # Number of bytes sampled per pseudorandom field element.\r\n    EXPANDED_SIZE: int\r\n\r\n    # Expand the input `seed` into the number of bytes requested.\r\n    @classmethod\r\n    def expand(cls, seed: bytes, info: bytes, length: int) -> bytes:\r\n        raise Error(\"not implemented\")\r\n\r\n    # Derive a fresh seed from an existing one.\r\n    @classmethod\r\n    def derive(cls, seed: bytes, info: bytes) -> bytes:\r\n        return cls.expand(seed, info, cls.SEED_SIZE)\r\n\r\n    # Expand the input `seed` into vector of `length` field elements. This\r\n    # algorithm is based on \"hash_to_field\" in draft-irtf-cfrg-hash-to-curve13.\r\n    @classmethod\r\n    def expand_into_vec(cls, Field, seed: bytes, info: bytes, length: int):\r\n        L = Field.EXPANDED_SIZE\r\n        len_in_bytes = length * L\r\n        uniform_bytes = cls.expand(seed, info, len_in_bytes)\r\n\r\n        vec = []\r\n        for i in range(0, len(uniform_bytes), L):\r\n            tv = uniform_bytes[i:i+L]\r\n            x = OS2IP(tv)\r\n            vec.append(Field(x))\r\n        return vec\r\n```",
          "createdAt": "2022-02-08T01:21:33Z",
          "updatedAt": "2022-02-08T01:24:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "> @schoppmp made an excellent point, which we ought to take into account: hash_to_field appears to be designed for entropy extraction.\r\n\r\nFWIW, I don't think this is correct. ",
          "createdAt": "2022-02-08T13:54:36Z",
          "updatedAt": "2022-02-08T13:54:36Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton I don't think this approach works directly as you describe it. The reason is that if the field modulus p is small-ish (e.g., 32 bits), then just taking 32 uniform bits and reducing them mod p will result in something far from uniform. This is what hash_to_curve fixes by increasing L by the security parameter k. \r\n\r\nMy point was twofold: \r\n1. If we want to sample n prime field elements from a single seed, we don't need log(p) + k uniform bits for *every* element we sample, but something more on the order of log(p) * n + k + log(n) for *all* n samples. (Edit: Fixed the formula)\r\n2. If our seed is uniform, then using AES (either in counter mode or as a [hash function](https://eprint.iacr.org/2019/074.pdf)) might be cheaper than SHA(KE).\r\n\r\n@chris-wood Could you elaborate with which part you disagree?",
          "createdAt": "2022-02-08T17:13:43Z",
          "updatedAt": "2022-02-08T17:26:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "> @chris-wood Could you elaborate with which part you disagree?\r\n\r\nWith one exception, I don't disagree with anything you wrote in that comment. I was merely responding to the \"entropy extraction\" point, which is not an explicit goal of hash-to-field.\r\n\r\n> If our seed is uniform, then using AES (either in counter mode or as a [hash function](https://eprint.iacr.org/2019/074.pdf)) might be cheaper than SHA(KE).\r\n\r\nI may be misunderstanding you, but this seems like a non sequitur since `expand_message` will work for any input, regardless of its distribution. In any case, I think it's reasonable to require the seed to be uniformly distributed. And using a stream cipher instead of hash-based `expand_message` certainly seems like an improvement. (In fact, we should consider adding such variant to the hash-to-curve draft!)",
          "createdAt": "2022-02-08T17:18:44Z",
          "updatedAt": "2022-02-08T17:18:44Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "> @schoppmp     1. If we want to sample n prime field elements from a single seed, we don't need log(p) + k uniform bits for _every_ element \r\nwe sample, but something more on the order of log(p) + n * k + log(n) for _all_ n samples.\r\n\r\nDo you mean `(log(p) + n) * k + log(n)` or `log(p) + (n * k) + log(n)`?\r\n",
          "createdAt": "2022-02-08T17:23:14Z",
          "updatedAt": "2022-02-08T17:23:14Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> I may be misunderstanding you, but this seems like a non sequitur since expand_message will work for any input, regardless of its distribution.\r\n\r\nIf we want pseudorandom outputs, then the seed needs to be be pseudorandom as well, or, alternatively, have high entropy so we can use a hash function (e.g. SHA) to reduce it to a uniform pseudorandom seed. I think the second part is what @cjpatton meant by entropy extraction.\r\n\r\n> Do you mean (log(p) + n) * k + log(n) or log(p) + (n * k) + log(n)?\r\n\r\nI actually meant `(log(p) * n) + k + log(n)` :smile: . I'll fix the comment above.\r\n",
          "createdAt": "2022-02-08T17:25:09Z",
          "updatedAt": "2022-02-08T17:25:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "@schoppmp right -- it doesn't extract entropy. Garbage in means garbage out. =) In any case, I think we're aligned now.",
          "createdAt": "2022-02-08T17:27:20Z",
          "updatedAt": "2022-02-08T17:27:20Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "@schoppmp Very interesting. Would you mind writing down the algorithm for mapping a `(log(p) * n) + k + log(n)` bits to `n` field elements? I'm curious how the extra `k + log(n)` bits are used. (You can also refer me to the IDPF code base.)",
          "createdAt": "2022-02-08T17:34:41Z",
          "updatedAt": "2022-02-08T17:34:41Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure, you can have a look [here](https://github.com/google/distributed_point_functions/blob/master/dpf/int_mod_n.h#L155). Note that the current implementation only works on 128-bit blocks, which limits the maximum `k` supported.",
          "createdAt": "2022-02-08T17:56:06Z",
          "updatedAt": "2022-02-08T17:56:06Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "Alright, this is super neat. Me and @armfazh are going to work on benchmarking (in libprio) rejection sampling vs pad-then-reduce (a la hash_to_field) vs @schoppmp's algorithm. We should have this done today. \r\n\r\nIn the meantime, @schoppmp: Would you mind working on an alternative PR to #25 that specifies your algorithm?\r\n\r\nEDIT: By the way, I think it would make sense to fix the same \"security parameter\" (say, 64) for all fields, and possibly exclude fields that are too small for this sampling method to be statistically close to uniform (e.g., less than 64 bits). See also #22.",
          "createdAt": "2022-02-08T18:20:25Z",
          "updatedAt": "2022-02-08T18:52:12Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "I've implemented both approaches PRs (linked to this issue).",
          "createdAt": "2022-02-14T21:40:23Z",
          "updatedAt": "2022-02-14T21:40:23Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "NONE",
          "body": "A comparison of three methods can be found at: https://github.com/abetterinternet/libprio-rs/compare/main...armfazh:prg/bench?expand=1\r\n\r\n|Method|N=10|N=100|N=1000|\r\n|:---|---:|---:|---:|\r\n| Rejection Sampling | 5.2 |  7.8 |  38.1 |\r\n| Pad-and-reduce     | 4.8 | 15.1 | 115.8 |\r\n| Borrow-and-reduce  | 4.5 | 12.7 |  83.7 |\r\n\r\n\\* Timings are \u00b5s measured in Core i7-8650U CPU @ 1.90GHz.\r\n\r\n\r\n",
          "createdAt": "2022-02-23T17:45:37Z",
          "updatedAt": "2022-02-23T17:45:37Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "Thanks @armfazh. Based on this assessment, I think that we should specify rejection sampling. @schoppmp do you object?\r\n",
          "createdAt": "2022-02-24T01:01:02Z",
          "updatedAt": "2022-02-24T01:01:02Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "An issue with rejection sampling is that it's hard to do with a constant-time implementation, which was also observed in the [hash-to-curve](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve#section-5) draft. Is your implementation returning early after the required number of finite field elements have been sampled? Or is it always sampling enough times to ensure the probability of rejecting too many samples is small enough (wrt. the security parameter)?",
          "createdAt": "2022-02-24T12:19:16Z",
          "updatedAt": "2022-02-24T12:19:29Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "libprio-rs currently generates samples until it reaches the number of field elements requested. This means the runtime is not bounded (in particular it's *definitely* not constant time!): \ufeffhttps://github.com/abetterinternet/libprio-rs/blob/main/src/prng.rs#L56-L82\r\n\r\nIncidentally, @armfazh noted that the current IDPF implementation is also not constant time, due to the division by the modulus here: https://github.com/abetterinternet/libprio-rs/blob/main/src/prng.rs#L56-L82. Though this should be easy enough to fix.\r\n\r\nTaking a step back, do we actually care if the algorithm that computes the mapping from pseudorandom byte strings to field elements is constant time? Take rejection sampling, for instance: assuming the underlying PRG is constant-time (i.e., AES-CTR is implemented in constant time) It seems to me that all that can be leaked by a non-constant-time implementation is the value of the bits that are rejected.",
          "createdAt": "2022-02-24T16:11:48Z",
          "updatedAt": "2022-02-24T16:11:48Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> Incidentally, @armfazh noted that the current IDPF implementation is also not constant time, due to the division by the modulus here: https://github.com/abetterinternet/libprio-rs/blob/main/src/prng.rs#L56-L82. Though this should be easy enough to fix.\r\n\r\nNot sure what you mean, the link goes to libprio-rs. AFAICT all branches in the [DPF sampling function](https://github.com/google/distributed_point_functions/blob/master/dpf/int_mod_n.h#L155) are based on loop variables or compile-time constants.\r\n\r\n> Taking a step back, do we actually care if the algorithm that computes the mapping from pseudorandom byte strings to field elements is constant time? Take rejection sampling, for instance: assuming the underlying PRG is constant-time (i.e., AES-CTR is implemented in constant time) It seems to me that all that can be leaked by a non-constant-time implementation is the value of the bits that are rejected.\r\n\r\nMaybe you are right and that leakage is fine (in that it can be simulated in a proof). @chris-wood, do you have an insight as to why constant-time is required for hash-to-curve and thus rejection sampling is ruled out?",
          "createdAt": "2022-02-24T17:27:07Z",
          "updatedAt": "2022-02-24T17:27:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "> Maybe you are right and that leakage is fine (in that it can be simulated in a proof). @chris-wood, do you have an insight as to why constant-time is required for hash-to-curve and thus rejection sampling is ruled out?\r\n\r\nYeah -- some applications of hash-to-curve operate on secret input, and thus any side channels may leak the secret. [Dragonblood](https://papers.mathyvanhoef.com/wac2019-slides.pdf) is one famous example of this that motivated the hash-to-curve standard.",
          "createdAt": "2022-02-24T17:32:03Z",
          "updatedAt": "2022-02-24T17:32:03Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "Ugh, sorry I copied the wrong link. I'm on a Mac and feel wayyy out of my depth :) Here's the link: https://github.com/google/distributed_point_functions/blob/master/dpf/int_mod_n.h#L170. I'm not sure this is guaranteed to be constant-time, i.e., the runtime of the division operation might depend on the value of `r`. I think this depends on the CPU arch.\r\n\r\n\r\n\r\n",
          "createdAt": "2022-02-24T17:34:25Z",
          "updatedAt": "2022-02-24T17:34:25Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton Ah got it. Yeah, I was assuming arithmetic operations are constant-time, but they might not be. In that case the fix should still be easy as you pointed out.\r\n\r\n@chris-wood So it seems that the number of iterations needed for many hashes of the same password + different auxiliary information (MAC, counter, ...) can be used to find the password. On the other hand, revealing even full blocks of an AES-CTR output shouldn't reveal anything about the key or any other blocks in the output. So is the issue in Dragonblood that the password is low-entropy?",
          "createdAt": "2022-02-24T18:15:06Z",
          "updatedAt": "2022-02-24T18:15:06Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "Seems like we may have consensus for rejection sampling. Here's a PR: https://github.com/cjpatton/vdaf/pull/31. @schoppmp if you're happy with this outcome then please review at your convenience :)",
          "createdAt": "2022-02-25T00:51:38Z",
          "updatedAt": "2022-02-25T00:51:38Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "SGTM, provided we emphasize that the seed MUST be high-entropy, i.e., not derived from a password using a KDF or similar. I'll take a look at #31.",
          "createdAt": "2022-02-25T13:30:13Z",
          "updatedAt": "2022-02-25T13:30:13Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "Actually I think high entropy (or, to be more precise, high min-entropy) won't be sufficient for all PRG constructions. See comments on the PR.",
          "createdAt": "2022-02-25T15:43:24Z",
          "updatedAt": "2022-02-25T15:43:24Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOGKuqOc5A-WhR",
      "title": "prio3: Make joint randomness optional",
      "url": "https://github.com/cjpatton/vdaf/issues/15",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Not all FLPs take joint randomness as input, in particular those for which `JOINT_RAND_LEN == 0`. For these FLPs we can reduce the bandwidth overhead by removing the `k_blind` and `k_hint` fields from the input share and the `k_joint_rand_share` from the prepare message.",
      "createdAt": "2021-12-28T19:27:29Z",
      "updatedAt": "2022-02-09T04:35:39Z",
      "closedAt": "2022-02-09T04:35:39Z",
      "comments": []
    },
    {
      "number": 18,
      "id": "I_kwDOGKuqOc5CXBsP",
      "title": "Threat model and protocol for distributed setup",
      "url": "https://github.com/cjpatton/vdaf/issues/18",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The \"setup\" algorithm defined in the spec specifies the generation of the public parameter used by the clients and verification parameter of each of the aggregators. This algorithm is said to run \"out-of-band\", effectively punting this consideration to applications. In particular, this is a problem that PPM will have to solve: see https://github.com/abetterinternet/ppm-specification/issues/161.\r\n\r\nWe know that the setup algorithm being run securely is crucial correctness, however it's not clear how important it is for privacy. As a strawman, suppose that we have one aggregator run the setup algorithm and distribute the output among the parties such that the clients never learn or control the value of the verification parameters. This ought to be good enough for correctness. What's less clear (to me, at least) is whether the aggregator, by choosing the verification parameters maliciously, can force an honest aggregator into revealing something that leads to a privacy violation.\r\n\r\nIf this strawman is not sufficient and we end up needing to do something fancier, then it may prudent to revisit the \"setup algorithm\" abstraction. What we woiuld want for prio3 and poplar1 is a protocol for exchanging a shared secret. (The properties we need from this key exchange are TBD, but note that something like a DH key exchange might not suffice. See https://github.com/abetterinternet/ppm-specification/issues/161 for discussion.)",
      "createdAt": "2022-01-25T01:53:41Z",
      "updatedAt": "2022-01-31T11:28:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "One thing to keep in mind is that the randomness used in the verification protocol (at least for Poplar) must be independent of the client keys. If a (semi-honest) helper server colludes with a (malicious) client, the client could use the randomness known to the helper server to generate an invalid share that still passes the verification. So I would propose running the setup phase only after all client shares have been collected and agreed on by the helper servers.\r\n\r\nRegarding maliciously generated randomness, are we considering malicious security for the helpers at all? If so, what exact formalization? For example, Poplar only provides malicious security with respect to privacy (but not correctness). Not sure we want to hard-code this threat model or instead leave it up to implementations.",
          "createdAt": "2022-01-25T10:32:56Z",
          "updatedAt": "2022-01-25T10:33:57Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "> One thing to keep in mind is that the randomness used in the verification protocol (at least for Poplar) must be independent of the client keys. If a (semi-honest) helper server colludes with a (malicious) client, the client could use the randomness known to the helper server to generate an invalid share that still passes the verification.\r\n\r\nMost definitely. In fact, this is likely going to be true for most, if not all, VDAFs. \r\n\r\n> So I would propose running the setup phase only after all client shares have been collected and agreed on by the helper servers.\r\n\r\nThis isn't going to feasible for all deployments for PPM. In particular, a deployment of prio3 might throw report shares away as soon as they're aggregated, in order to limit storage overhead. Regardless, I think the main requirement is that the randomness is kept secret from the clients, which is definitely feasible.\r\n\r\n> Regarding maliciously generated randomness, are we considering malicious security for the helpers at all? If so, what exact formalization? For example, Poplar only provides malicious security with respect to privacy (but not correctness). Not sure we want to hard-code this threat model or instead leave it up to implementations.\r\n\r\nYes, as stated in our security considerations: for privacy we're concerned with malicious aggregators, but for correctness we assume the aggregators are honest. This amounts to the clients only needing to trust at least one aggregator for privacy, however the collector needs to trust that the aggregators compute the protocol correctly.\r\n\r\nThe main point raised in https://github.com/abetterinternet/ppm-specification/issues/161 is that there is a gap in the thread model not addressed by [BBCGGI19] or [BBCGGI21] (Poplar): The shared randomness used for verification may be controlled by the attacker. [BBCGGI19] and [BBCGGI21] side-step this by assuming an ideal \"coin-flipping\" functionality in the protocol. In practice, this coin-flipping functionality needs to be realized by some interaction among the aggregators.\r\n\r\nThus the main question I'm asking here is what properties do we actually need from the coin-flipping protocol. In particular: If we allow the attacker to control the honest aggregators' long lived randomness, are `poplar1` and `prio3` still private? This was discussed a bit in https://github.com/abetterinternet/ppm-specification/issues/161, but I'm not sure we have a definitive answer (at least for prio3).\r\n   * If yes, then the strawman setup procedure described above will suffice and we're done.\r\n   * If no, then we'll have to decide whether to consider an alternative here or leave this to applications like PPM.",
          "createdAt": "2022-01-25T15:57:21Z",
          "updatedAt": "2022-01-25T15:57:21Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "I think there are two questions here:\r\n1. How do we handle collusions between one of the servers and a subset of clients with respect to correctness? \r\n2. (Your question) Does a maliciously chosen randomness affect the privacy of the protocols?\r\n\r\nRegarding (1): Even though we don't care about correctness for malicious server behavior, a semi-honest server colluding with malicious clients might still be a problem. For example, in reality, we could enforce semi-honest helper servers using some form of binary attestation. But that wouldn't stop a malicious admin from reading out the verification randomness and then running a client with an invalid input that still passes verification with that randomness.\r\n> Regardless, I think the main requirement is that the randomness is kept secret from the clients, which is definitely feasible.\r\n\r\nGiven the example above, I'm not sure it is always realistic to assume that the randomness is kept secret from all clients. So I would like to at least keep the option to only generate the randomness once the client shares are agreed on. If we want to allow Fiat-Shamir as discussed in abetterinternet/ppm-specification#161, this would be required anyway.\r\n\r\nRegarding (2): I had a brief look at Poplar, and it doesn't seem like adversary-chosen randomness can break privacy. In particular, Proposition 2 in [Appendix C.4.1](https://eprint.iacr.org/2021/017.pdf#page=19&zoom=100,417,856) still holds (the simulator does not require r to be random). Maybe @henrycg has some insights for Prio?",
          "createdAt": "2022-01-26T14:05:00Z",
          "updatedAt": "2022-01-26T14:05:00Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "> But that wouldn't stop a malicious admin from reading out the verification randomness and then running a client with an invalid input that still passes verification with that randomness.\r\n\r\nSince this involves sharing information with the client -- or, equivalently, acting as a client itself -- I would consider this malicious (i.e., active) behavior on the part of the server and, therefore, out of scope.\r\n\r\n>  So I would like to at least keep the option to only generate the randomness once the client shares are agreed on.\r\n\r\nI think keeping this option is reasonable. One question though: Is this a matter to be considered by the VDAF spec or by applications? We could discuss the attack you described above in security considerations and recommend setting up the verification parameters only after the input shares have been ingested.\r\n\r\n> If we want to allow Fiat-Shamir as discussed in abetterinternet/ppm-specification#161, this would be required anyway.\r\n\r\nCan you provide more detail here? We use Fiat-Shamir in prio3 for the \"joint randomness\", but not the \"query randomness\". I agree that there's an attack if the client knows the shared secret used to derive query randomness, but I don't see an attack if the shared secret is generated before the client generates its input shares (as long as it doesn't see it). Am I missing something?",
          "createdAt": "2022-01-26T15:38:19Z",
          "updatedAt": "2022-01-26T16:43:24Z"
        },
        {
          "author": "henrycg",
          "authorAssociation": "NONE",
          "body": "> Regarding (2): I had a brief look at Poplar, and it doesn't seem like adversary-chosen randomness can break privacy. In particular, Proposition 2 in [Appendix C.4.1](https://eprint.iacr.org/2021/017.pdf#page=19&zoom=100,417,856) still holds (the simulator does not require r to be random). Maybe @henrycg has some insights for Prio?\r\n\r\nYes, the same should be true for Prio, provided that the servers' random challenge is chosen, as in the Crypto'19 paper, to avoid the certain set of \"bad\" challenge points.",
          "createdAt": "2022-01-26T16:02:41Z",
          "updatedAt": "2022-01-26T16:02:41Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> Can you provide more detail here? We use Fiat-Shamir in prio3 for the \"joint randomness\", but not the \"query randomness\". I agree that there's an attack if the client knows the shared secret used to derive query randomness, but I don't see an attack if the shared secret is generated before the client generates its input shares (as long as it doesn't see it). Am I missing something?\r\n\r\nOkay, so this means that you use fiat-shamir to derive the randomness used in each client's proof share, but not the randomness that is sampled independently by the servers using coin-flipping? In that case you are right, we don't need to wait until we know all client shares.\r\n\r\nStill, the issue regarding a server colluding with a malicious client stands. I'm not sure we can simply discount it for being \"out of scope\", given the example attack scenario I gave above. Or, to put it in more formal terms, I don't see why we should require the adversary to corrupt all parties in the same way, given that some (clients) are more easy to corrupt maliciously than others (helper servers).",
          "createdAt": "2022-01-26T16:59:20Z",
          "updatedAt": "2022-01-26T16:59:28Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is this a matter to be considered by the VDAF spec or by applications? We could discuss the attack you described above in security considerations and recommend setting up the verification parameters only after the input shares have been ingested.\r\n\r\nDo you think we should discuss this in the PPM spec as well (e.g. in abetterinternet/ppm-specification#161)?",
          "createdAt": "2022-01-26T17:02:26Z",
          "updatedAt": "2022-01-26T17:02:26Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "That's an interesting point, and I agree that there's no reason to think of all parties as being corrupted in the same way. Definitely worth thinking about.\r\n\r\nI'll just add this thought: If a malicious aggregator wants to break correctness, there's a much simpler attack than corrupting or acting as a client: all it has to do is make up a bogus aggregate share. The collector would have no way to detect this, at least for prio3 or poplar1.",
          "createdAt": "2022-01-28T03:15:28Z",
          "updatedAt": "2022-01-28T03:15:28Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'll just add this thought: If a malicious aggregator wants to break correctness, there's a much simpler attack than corrupting or acting as a client: all it has to do is make up a bogus aggregate share. The collector would have no way to detect this, at least for prio3 or poplar1.\r\n\r\nI assume you mean a malicious admin or similar insider would run this simpler attack at the aggregator service? Then it wouldn't work any more if there are additional measurements (e.g., binary attestation) to enforce semi-honest behavior of the aggregator process, whereas reading out the verification randomness and then uwing it with a maliciously crafted client message would still work. \r\n\r\nOverall, even if we only consider outside attackers, I believe leaking some secret value from one of the aggregator servers is easier (requires less severe vulnerabilities or exploits) than triggering a remote code execution to cheat during the aggregation protocol.",
          "createdAt": "2022-01-28T11:38:51Z",
          "updatedAt": "2022-01-28T11:38:51Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "\r\n> I assume you mean a malicious admin or similar insider would run this simpler attack at the aggregator service? Then it wouldn't work any more if there are additional measurements (e.g., binary attestation) to enforce semi-honest behavior of the aggregator process, whereas reading out the verification randomness and then uwing it with a maliciously crafted client message would still work.\r\n\r\nBinary attestation would be super useful, but I don't think it will be used in all applications of VDAFs.\r\n\r\nRegardless, I think the threat you're describing is worth discussing in security considerations, and we could even RECOMMEND that, where feasible, the setup algorithm be run only after the batch of input shares has arrived. However I would not go so far as to say deployments MUST or even SHOULD do this. Do you think this would be a reasonable outcome?",
          "createdAt": "2022-01-28T16:05:45Z",
          "updatedAt": "2022-01-28T16:05:45Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "That sounds good to me. I opened #21 for that, PTAL.",
          "createdAt": "2022-01-31T11:28:59Z",
          "updatedAt": "2022-01-31T11:28:59Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "I_kwDOGKuqOc5CXDUr",
      "title": "VDAFs that use the public parameter?",
      "url": "https://github.com/cjpatton/vdaf/issues/19",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The \"setup\" algorithm outputs a public parameter used by the clients to shard their measurement into input shares. This was added to the syntax in anticipation of VDAFs that might make use of public-key cryptography in some way. For example, in the appendix, [BBCGGI19] describes alternative applications for FLPs, e.g., using homomorphic encryption. One can imagine a VDAF that uses homomorphic encryption in order to save a round trip for input validation. (This is basically what [AdScale](https://isi.jhu.edu/~mgreen/advertising.pdf) does, as I understand.)\r\n\r\nThis is a bit of a pain for PPM, since it means that rotating the verification parameter also requires re-configuring the clients with the new public parameter. (See https://github.com/abetterinternet/ppm-specification/issues/161.) Since we don't yet have a VDAF that makes use of the public parameter, it might be preferable to drop it from the syntax.",
      "createdAt": "2022-01-25T02:06:43Z",
      "updatedAt": "2022-01-25T02:06:43Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 20,
      "id": "I_kwDOGKuqOc5CbTK5",
      "title": "What to do about DAFs (VDAFs w/o verifiability)",
      "url": "https://github.com/cjpatton/vdaf/issues/20",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The syntax is compatible with schemes that forego verifiability altogether, but calling such a scheme a \"VDAF\" would be misleading. It's probably a good idea to make this distinction explicit, i.e., define \"DAFs\" as 0-round VDAFs that provide no verifiability. Should we make room for this in this document, or does it make sense to kick this to a different document?\r\n\r\nNote that this question came up previously in the context of PPM: https://github.com/abetterinternet/ppm-specification/issues/45.",
      "createdAt": "2022-01-25T23:10:00Z",
      "updatedAt": "2022-01-25T23:52:10Z",
      "closedAt": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "In case it helps, the [VOPRF document](https://cfrg.github.io/draft-irtf-cfrg-voprf/draft-irtf-cfrg-voprf.html) includes OPRFs with and without verifiability. I think it makes sense to include DAFs in this document, especially for deployments that don't need verifiability.",
          "createdAt": "2022-01-25T23:52:10Z",
          "updatedAt": "2022-01-25T23:52:10Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "I_kwDOGKuqOc5C4vjo",
      "title": "Specify fields for poplar1 (was \"Specify fields for prio3 and poplar1\")",
      "url": "https://github.com/cjpatton/vdaf/issues/22",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "At this point we have fairly clear criteria for choosing fields for Prio. Namely, the prime modulus `p` should be of the form `2^k * q + 1`, where `k` is large enough to support proof sizes we're interested in. The fact that the multiplicative group has a subgroup of order `2^k` is exploited for fast polynomial interpolation. `k` should also be chosen to align with the word size of the machine, e.g., `32` or `64` so that fast arithmetic can be generated for it (cc/ @armfazh).\r\n\r\nThe requirements are different for Poplar, though any field we choose for Prio ought to be suitable for Poplar as well. The main difference I see is that we'll need a much larger field for the leaves of the IPDF tree than we need for the inner nodes. I wonder if the leaves could use `GF(2^255 - 19)`, since there are already fast, heavily vetted implementation of this field (namely for X25519 and ed25519)? @schoppmp do you have any other thoughts here?",
      "createdAt": "2022-02-02T16:59:10Z",
      "updatedAt": "2022-03-04T01:45:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "As far as how big the primes ought to be, I think we ought to aim for a soundness error of around 1/2^64 for any VDAF. Higher security levels can be targeted as desired.\r\n\r\nFor prio3, we should have:\r\n* a 64-bit field. This would only be appropriate for instantiations that don't do Fiat-Shamir.\r\n* a 96-bit field. Similarly, this would not be appropriate for Fiat-Shamir.\r\n* a 128-bit field. This would be suitable for Fiat-Shamir.\r\n\r\nFor poplar1 we might reuse these fields, or pick new ones if the fields we pick for prio3 aren't suitable. We will also need:\r\n* a 256-bit field (or close to it). It may be worthwhile to pick something suitable for prio3.",
          "createdAt": "2022-02-02T17:58:50Z",
          "updatedAt": "2022-02-02T18:02:41Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "The document now specifies a 64-bit and a 128-bit field suitable for prio3.",
          "createdAt": "2022-03-04T01:45:53Z",
          "updatedAt": "2022-03-04T01:45:53Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "I_kwDOGKuqOc5El_DQ",
      "title": "PRGs",
      "url": "https://github.com/cjpatton/vdaf/issues/32",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Our initial PRG construction is based on AES: https://github.com/cjpatton/vdaf/pull/28. @schoppmp points out that there may alternative AES-based constructions that are better suited to our application. In addition, there may be alternative primitives, like an XOF hash function, that are well suited for VDAFs. This issue is for tracking this discussion.",
      "createdAt": "2022-02-25T19:49:52Z",
      "updatedAt": "2022-03-09T18:04:40Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "Here's the paper Phillipp referenced: https://eprint.iacr.org/2019/074.pdf",
          "createdAt": "2022-03-09T18:04:39Z",
          "updatedAt": "2022-03-09T18:04:39Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "I_kwDOGKuqOc5FZnLF",
      "title": "Specifing serializaiton of verification parameter",
      "url": "https://github.com/cjpatton/vdaf/issues/38",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "As @tgeoghegan pointed out in https://github.com/abetterinternet/libprio-rs/pull/192#issuecomment-1062483035, some applications will require transmitting verification parameters over a secure channel. To support these, we we ought to require that VDAFs specify an encoding.",
      "createdAt": "2022-03-09T19:20:51Z",
      "updatedAt": "2022-03-09T19:20:51Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 39,
      "id": "I_kwDOGKuqOc5FxJ2w",
      "title": "prio3: Shorten the prepare message",
      "url": "https://github.com/cjpatton/vdaf/issues/39",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "By moving `decide()` into `prep_shares_to_prep()` we can avoid sending the unsharded verifier message over the network.",
      "createdAt": "2022-03-16T04:05:40Z",
      "updatedAt": "2022-03-16T04:05:40Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 40,
      "id": "I_kwDOGKuqOc5GLehI",
      "title": "Does VDAF need a notion of leader?",
      "url": "https://github.com/cjpatton/vdaf/issues/40",
      "state": "OPEN",
      "author": "tgeoghegan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "PPM has a notion of a distinguished aggregator called the \"leader\". Wherever messages contain a sequence of objects, that protocol insists that the leader's share always be the first element (e.g. [`Report.encrypted_input_shares`](https://www.ietf.org/archive/id/draft-gpew-priv-ppm-01.html#section-4.2.2-4.4)).\r\n\r\nVDAF only references the notion of a leader in its specification of `Prio3`, [whose input sharding algorithm does specify that the leader's share appears first](https://www.ietf.org/archive/id/draft-patton-cfrg-vdaf-01.html#section-6.2.2).\r\n\r\nHowever that constraint isn't articulated generically for all VDAFs, which leaves things ambiguous for implementations. Consider the current generic declaration of [`prio::vdaf::Client::shard`](https://docs.rs/prio/latest/prio/vdaf/trait.Client.html):\r\n```\r\n    /// Shards a measurement into a sequence of input shares, one for each Aggregator.\r\n    fn shard(\r\n        &self,\r\n        public_param: &Self::PublicParam,\r\n        measurement: &Self::Measurement,\r\n    ) -> Result<Vec<Self::InputShare>, VdafError>;\r\n```\r\nPPM implementations have to guess that the 0th element in the returned `Vec` is the leader's share. Should the [VDAF-level definition of `shard`](https://www.ietf.org/archive/id/draft-patton-cfrg-vdaf-01.html#section-4.2) discuss the notion of a leader share, and require that the 0-th value returned from `Vdaf.measurement_to_input_shares` be the leader's?\r\n",
      "createdAt": "2022-03-22T23:31:13Z",
      "updatedAt": "2022-03-23T00:04:02Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "I agree this ambiguity matters to PPM -- or, more generally, the Leader/Model architecture -- insofar that it makes sense to send the \"big\" share to the leader in order to decrease communication cost for the helpers. It's also true that this asymmetry --- i.e., the existence of a distinguished \"big\" share -- exists for Prio3 and, to a lesser extend, Poplar1; but it's worth pointing out that the asymmetry doesn't necessarily exist for all VDAFs.\r\n\r\nFor this reason, my view here is that it's not worth making a syntactic change to the VDAF spec in order to accommodate this. What I would go for is adding guidance somewhere in the spec to nudge things in the right direction. In particular: would it be sufficient to RECOMMEND that future VDAFs put the \"big\" share first (if it exists)?",
          "createdAt": "2022-03-22T23:47:23Z",
          "updatedAt": "2022-03-22T23:48:11Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure that a recommendation will suffice. If there's a difference in the encoding of one share vs. the others, then a PPM implementation needs to able to tell which one is different so it can be sent to the aggregator that is configured to handle that kind of share.\r\n\r\nAlternatively, an encoded input share could include some indication of how it is encoded (e.g. whether or not it's compressed in prio3) and then `Vdaf.prep_init` could use that inline information to decide how to decode the input share.",
          "createdAt": "2022-03-22T23:57:26Z",
          "updatedAt": "2022-03-22T23:57:26Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "> I'm not sure that a recommendation will suffice. If there's a difference in the encoding of one share vs. the others, then a PPM implementation needs to able to tell which one is different so it can be sent to the aggregator that is configured to handle that kind of share.\r\n\r\nTrue enough. Right now the information needed to decode (and indeed to prepare an input) is encoded by the verification parameter: https://www.ietf.org/archive/id/draft-patton-cfrg-vdaf-01.html#name-setup-2. This seems sufficient, but  perhaps there's a better way to expose this?\r\n\r\nBy the way, to decode a Prio3 input share, you need to know more than whether the share is for the \"leader\" or a \"helper\". You also need the \"aggregator ID\", which is used in an essential way to compute the joint randomness. For Prio3 this is encoded by the verification parameter.\r\n\r\n> Alternatively, an encoded input share could include some indication of how it is encoded (e.g. whether or not it's compressed in prio3) and then `Vdaf.prep_init` could use that inline information to decide how to decode the input share.\r\n\r\nSeems reasonable, though it would cost a few bits of communication.",
          "createdAt": "2022-03-23T00:03:22Z",
          "updatedAt": "2022-03-23T00:04:02Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "I_kwDOGKuqOc5GkD62",
      "title": "Representing 'linear state machine' requirement in pseudocode",
      "url": "https://github.com/cjpatton/vdaf/issues/42",
      "state": "OPEN",
      "author": "divergentdave",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The following currently appears in section 4.3.\r\n\r\n> TODO Consider how to bake this \"linear state machine\" condition into the syntax. Given that Python 3 is used as our pseudocode, it's easier to specify the preparation state using a class.",
      "createdAt": "2022-03-28T19:00:08Z",
      "updatedAt": "2022-03-28T21:55:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My suggestion: If we augment our pseudocode with dependent types, then we could parameterize the type of `Prep` by how many rounds are left before the output share is recovered. Making up some syntax, this would look like:\r\n\r\n```\r\nVdaf.prep_init(verify_param: VerifyParam, agg_param: AggParam, nonce: Bytes, input_share: Bytes) -> Prep[ROUNDS]\r\n\r\nVdaf.prep_next(prep: Prep[ROUNDS], inbound: None) -> If[ROUNDS == 0, OutShare, Tuple[Prep[ROUNDS - 1], Bytes]]\r\nVdaf.prep_next(prep: Prep[R such that R < ROUNDS], inbound: Bytes) -> If[R == 0, OutShare, Tuple[Prep[R - 1], Bytes]]\r\n```",
          "createdAt": "2022-03-28T19:00:13Z",
          "updatedAt": "2022-03-28T21:55:48Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOGKuqOc4tFEy5",
      "title": "Edits",
      "url": "https://github.com/cjpatton/vdaf/pull/1",
      "state": "MERGED",
      "author": "tgeoghegan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Some clarifications and changes found while reviewing https://github.com/abetterinternet/libprio-rs/pull/93 and checking it against this document.\r\n\r\n- `vdaf_input` returns a vector of input shares rather than a single blob'o'bytes\r\n- make aggregation parameter more obvious in `vdaf_start`\r\n- remove obsolete references to ready and waiting states in Prio3 `vdaf_start` and `vdaf_finish` definitions",
      "createdAt": "2021-10-12T15:29:23Z",
      "updatedAt": "2021-10-12T16:29:27Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "c667b77422eabbe1cf1c8450f396e5ba54d887c8",
      "headRepository": "tgeoghegan/vdaf",
      "headRefName": "edits",
      "headRefOid": "0b2ae6afa5f8a8473cc5aa7baf6f0cfca206aac9",
      "closedAt": "2021-10-12T16:29:27Z",
      "mergedAt": "2021-10-12T16:29:26Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "d25be886346f3388b1972e540f5f38209e521401"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "PR_kwDOGKuqOc4tGzIf",
      "title": "Add an intro",
      "url": "https://github.com/cjpatton/vdaf/pull/2",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-12T21:43:32Z",
      "updatedAt": "2021-10-13T21:54:17Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "810e990a8c6cf03b6b21091d72fd394b6a68a6f9",
      "headRepository": "cjpatton/vdaf",
      "headRefName": "intro",
      "headRefOid": "12e409b59fcbff030a351de55606c562b8dd215d",
      "closedAt": "2021-10-13T21:54:17Z",
      "mergedAt": "2021-10-13T21:54:17Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "9d04d03236a215b29a3e9087159dfa2de1247692"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4uXdKU",
          "commit": {
            "abbreviatedOid": "6d91a58"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "This is great! A few comments.",
          "createdAt": "2021-10-12T21:57:25Z",
          "updatedAt": "2021-10-12T22:15:37Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "```suggestion\r\nThe remainder of this document is structured as follows:\r\n```",
              "createdAt": "2021-10-12T21:57:25Z",
              "updatedAt": "2021-10-12T22:15:37Z"
            },
            {
              "originalPosition": 29,
              "body": "This is a pretty good description of systems like RAPPOR, but I think it would be useful to speak about DP more broadly. Roughly speaking, differentially private data aggregation systems guarantee that the degree to which an individual user influences the aggregate output is small.",
              "createdAt": "2021-10-12T22:14:50Z",
              "updatedAt": "2021-10-12T22:15:37Z"
            },
            {
              "originalPosition": 36,
              "body": "In my view, the greater drawback of DP is the need to enforce a privacy budget. ",
              "createdAt": "2021-10-12T22:15:13Z",
              "updatedAt": "2021-10-12T22:15:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 3,
      "id": "PR_kwDOGKuqOc4tG5Ka",
      "title": "Some comments",
      "url": "https://github.com/cjpatton/vdaf/pull/3",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-12T22:12:05Z",
      "updatedAt": "2021-10-25T14:54:20Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "b23df123f181528e4b1fedbcc231d81e3a707a72",
      "headRepository": "cjpatton/vdaf",
      "headRefName": "rlb-review",
      "headRefOid": "be528b0101facbb7d53bdb18edf3a43b98175441",
      "closedAt": "2021-10-25T14:54:20Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4uXjtC",
          "commit": {
            "abbreviatedOid": "be528b0"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T22:32:02Z",
          "updatedAt": "2021-10-12T22:37:46Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "DAFs and VDAFs are meant to be distinct primitives. They differ in two important ways: VDAFs require the aggregators to interact; and DAFs don't provide any guarantee about the validity of the output. DAFs and VDAFs aren't necessarily \"compatible\" with one another. It's true that that there may be some overlap between specific constructions, but this isn't necessarily the case.\r\n\r\nTo be clear, VDAFs are the interesting primitive here. The main reason I defined DAFs is because they are conceptually simpler and provide a nice warm up to VDAFs. Perhaps we should just drop DAFs altogether?",
              "createdAt": "2021-10-12T22:32:02Z",
              "updatedAt": "2021-10-12T22:37:46Z"
            },
            {
              "originalPosition": 17,
              "body": "Validation applies to VDAFs, not DAFs.",
              "createdAt": "2021-10-12T22:32:47Z",
              "updatedAt": "2021-10-12T22:37:46Z"
            },
            {
              "originalPosition": 25,
              "body": "The aggregation parameter is what maps an input to an output. For heavy hitters for example, the aggregation parameter is the set of candidate prefixes. I'll make this more clear.",
              "createdAt": "2021-10-12T22:34:25Z",
              "updatedAt": "2021-10-12T22:37:46Z"
            },
            {
              "originalPosition": 31,
              "body": "Right, the way aggregability is defined currently is that the set of output shares is an algebraic group, and the output is recovered by adding up the output shares. Would defining an explicit \"unsharding\" algorithm be more clear, in your opinion?",
              "createdAt": "2021-10-12T22:35:33Z",
              "updatedAt": "2021-10-12T22:37:46Z"
            },
            {
              "originalPosition": 62,
              "body": "This is something that's a bit in-flux right now. I think where we're going to land is that the client gets a \"public key\" (the \"public parameter\") and each aggregator gets its own \"secret key\" (the \"verification parameter\").",
              "createdAt": "2021-10-12T22:37:02Z",
              "updatedAt": "2021-10-12T22:37:46Z"
            },
            {
              "originalPosition": 72,
              "body": "That's the plan! This is still very much WIP.",
              "createdAt": "2021-10-12T22:37:35Z",
              "updatedAt": "2021-10-12T22:37:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4ugW0-",
          "commit": {
            "abbreviatedOid": "be528b0"
          },
          "author": "ekr",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-14T20:48:19Z",
          "updatedAt": "2021-10-14T20:48:39Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "I think that's the right answer. It would be fine to describe it just in the process of describing a VDAF, but just to motivate the whole thing. The way I usually describe this is to just walk through what it means to be a DAF and then say \"of course you need proofs\" and then talk about the proofs. In this document  I would signal that at the beginning and then just define VDAFs.",
              "createdAt": "2021-10-14T20:48:19Z",
              "updatedAt": "2021-10-14T20:48:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 4,
      "id": "PR_kwDOGKuqOc4tcP5z",
      "title": "WIP: Define VDAF for heavy hitters",
      "url": "https://github.com/cjpatton/vdaf/pull/4",
      "state": "MERGED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-20T13:54:35Z",
      "updatedAt": "2021-10-25T09:29:17Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "fee81313bda6dde38d702c48a09bf2c2e8962c32",
      "headRepository": "cjpatton/vdaf",
      "headRefName": "vdaf_hits",
      "headRefOid": "f319d38c96aea2e7e960fdbf2e9450f68c32c270",
      "closedAt": "2021-10-22T23:27:51Z",
      "mergedAt": "2021-10-22T23:27:51Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "97c3ad0df641cd02734908475fb2de1a5f647e1b"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "It looks like you merged at some point to deal with conflicts. While trying to rebase I gave up and just force-pushed a commit with your patch.",
          "createdAt": "2021-10-22T23:27:08Z",
          "updatedAt": "2021-10-22T23:27:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4uxeF_",
          "commit": {
            "abbreviatedOid": "ed0fa2d"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "Good start! I left some mostly editorial comments to start. Some high level editorial things: \r\n* `make` fails due to trailing whitespace. Make sure you can run `make` locally and that it builds successfully. (If you've never built an Internet-Draft before, let me know and I can help you get started!)\r\n* Please wrap lines at 80 characters.\r\n\r\nAs for the design:\r\n1. The purpose of the nonce is to allow the aggregators to derive fresh randomness per VDAF evaluation. This randomness could be derived by applying a PRF to the nonce using the key generated for the verification parameters.\r\n2. I'm curious why you allow the caller to specify the group parameters for each level of the tree. I would think it's better if the scheme *prescribed* these parameters. In other words, a concrete IDPF would specify the field parameters of each level of the tree.",
          "createdAt": "2021-10-20T16:19:25Z",
          "updatedAt": "2021-10-20T16:34:35Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "* Replace this reference with `[BBCGGI21, Section 4.3]`\r\n* When this gets compiled, the markdown reference won't appear in the text version. The reference should be added to the  list of informative references at the top of this file.",
              "createdAt": "2021-10-20T16:19:25Z",
              "updatedAt": "2021-10-20T16:34:35Z"
            },
            {
              "originalPosition": 8,
              "body": "Add a newline between headings and the first line.",
              "createdAt": "2021-10-20T16:21:33Z",
              "updatedAt": "2021-10-20T16:34:35Z"
            },
            {
              "originalPosition": 17,
              "body": "?\r\n```suggestion\r\nAn IDPF is defined over a domain of size `2**d`. The client can specify an index `alpha` and values `beta`, one for each level `l` in `[d]`. The key generation generates two IDPF keys that individually hide `alpha` and `beta`. When locally evaluated at any point `x` in `2**l` at level `l`, the IDPF returns shares of `beta[l]`, if `x` is the `l`-bit prefix of `alpha`, and shares of zero otherwise.\r\n```",
              "createdAt": "2021-10-20T16:22:27Z",
              "updatedAt": "2021-10-20T16:34:35Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\n- `idpf_gen(value_types: Vec[ValueType], alpha: int, beta: Vec[Value]) -> (Bytes, Bytes)`: Takes as input the value types describing the IDPF output domains, as well as the index and values for the IDPF. Returns two serialized DPF keys, one for each aggregator.\r\n```",
              "createdAt": "2021-10-20T16:23:35Z",
              "updatedAt": "2021-10-20T16:34:35Z"
            },
            {
              "originalPosition": 21,
              "body": "Should `x` be unsigned? How about `Unsigned` as the type hint, for consistency with the section above?",
              "createdAt": "2021-10-20T16:24:28Z",
              "updatedAt": "2021-10-20T16:34:35Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\n### Malicious sketching for IDPFs\r\n```",
              "createdAt": "2021-10-20T16:26:36Z",
              "updatedAt": "2021-10-20T16:34:35Z"
            },
            {
              "originalPosition": 115,
              "body": "The nonce should be used to generate a seed for the verification randomness vector `r`. For example, in prio3 we have\r\n```python\r\ndef vdaf_start(k_query_init, _, nonce, r_input_share):  \r\n  ...\r\n  k_query_rand = get_key(k_query_init, byte(255) + nonce)\r\n  ...\r\n```\r\n\r\nwhere `k_query_init` is the verification parameter.",
              "createdAt": "2021-10-20T16:29:57Z",
              "updatedAt": "2021-10-20T16:34:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u1kkX",
          "commit": {
            "abbreviatedOid": "cdd7a84"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-21T14:35:44Z",
          "updatedAt": "2021-10-21T14:35:44Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I removed the second reference, since the value type implementation is not really important if we assume that the concrete scheme fixes the types for each level.",
              "createdAt": "2021-10-21T14:35:44Z",
              "updatedAt": "2021-10-21T14:35:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u1kn7",
          "commit": {
            "abbreviatedOid": "cdd7a84"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-21T14:35:55Z",
          "updatedAt": "2021-10-21T14:35:55Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Done.",
              "createdAt": "2021-10-21T14:35:55Z",
              "updatedAt": "2021-10-21T14:35:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u1kr_",
          "commit": {
            "abbreviatedOid": "cdd7a84"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-21T14:36:06Z",
          "updatedAt": "2021-10-21T14:36:07Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Done.",
              "createdAt": "2021-10-21T14:36:06Z",
              "updatedAt": "2021-10-21T14:36:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u1lIl",
          "commit": {
            "abbreviatedOid": "cdd7a84"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-21T14:37:25Z",
          "updatedAt": "2021-10-21T14:37:25Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "Done.",
              "createdAt": "2021-10-21T14:37:25Z",
              "updatedAt": "2021-10-21T14:37:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u3TbU",
          "commit": {
            "abbreviatedOid": "02a855d"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-10-21T22:19:46Z",
          "updatedAt": "2021-10-21T22:30:19Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\ndetails. An instantiation of this VDAF specifies a function `get_value_type(n: Unsigned) -> ValueType` that\r\n```",
              "createdAt": "2021-10-21T22:19:47Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nof a given group, and `Value` to refer to an actual element of the group.\r\n```",
              "createdAt": "2021-10-21T22:20:17Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 23,
              "body": "I know we're supposed to be doing everything in Python, but let's just write this as\r\n```suggestion\r\nAn IDPF is defined over a domain of size `2^d`. The client can specify an\r\n```",
              "createdAt": "2021-10-21T22:21:01Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 27,
              "body": "Would it be more accurate to say\r\n```suggestion\r\nWhen locally evaluated at any point `x` in `2**l` at level `l`, the IDPF\r\nkey returns a share of `beta[l]`, if `x` is the `l`-bit prefix of `alpha`, and\r\n```",
              "createdAt": "2021-10-21T22:22:35Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 31,
              "body": "I've been naming the output parameters. How about `-> (idpf_key1: Bytes, idpf_key2: Bytes)` or something?",
              "createdAt": "2021-10-21T22:24:05Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nkeys, one for each aggregator.\r\n```",
              "createdAt": "2021-10-21T22:24:16Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 34,
              "body": "```suggestion\r\n- `idpf_eval_next(state: State, idpf_key: Bytes, x: Unsigned) `\r\n```",
              "createdAt": "2021-10-21T22:25:07Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 44,
              "body": "Above I use \"joint rand\" to refer to randomness shared by the prover and verifier for PCPs. Can we call this something else, like \"verify_rand\"?",
              "createdAt": "2021-10-21T22:26:55Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 44,
              "body": "Here and elsewhere\r\n```suggestion\r\n  r = expand_rand(joint_randomness, len(idpf_output), level)\r\n```",
              "createdAt": "2021-10-21T22:27:10Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 47,
              "body": "Here and below\r\n```suggestion\r\n    [value[0] for value in dpf_output,\r\n```",
              "createdAt": "2021-10-21T22:28:01Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 133,
              "body": "I'm having a hard time understanding what's going on here. It seeems like you want the IDPF api to be stateful, but the VDAF api is not. So how does the state of the IPDF get passed through to subsequent VDAF evaluations?\r\n\r\nUnless I'm misunderstanding, I think the answer is that, at least as far as this spec is concerned, the IDPF api needs to be stateless. ",
              "createdAt": "2021-10-21T22:30:13Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u42C9",
          "commit": {
            "abbreviatedOid": "dda25de"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T09:56:12Z",
          "updatedAt": "2021-10-22T09:56:12Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "Not sure I understand the statefull / stateless distinction here.\r\nIn the [input evaluation](https://github.com/cjpatton/vdaf/blob/main/draft-patton-cfrg-vdaf.md#input-evaluation) section, it seems like there is an `EvalState` that is kept between the communication rounds between the aggregators. Wouldn't this state also be able to contain the partially evaluated IDPF state? The IDPF-based heavy hitter protocol needs to keep some sort of state between rounds. We could of course emulate that by sending the state back and forth encrypted, but I think that would unnecessarily limit implementations who might want to keep state locally.",
              "createdAt": "2021-10-22T09:56:12Z",
              "updatedAt": "2021-10-22T09:56:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u5Rbs",
          "commit": {
            "abbreviatedOid": "dda25de"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T12:08:41Z",
          "updatedAt": "2021-10-22T12:08:41Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Done.",
              "createdAt": "2021-10-22T12:08:41Z",
              "updatedAt": "2021-10-22T12:08:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u5Rn0",
          "commit": {
            "abbreviatedOid": "dda25de"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T12:09:31Z",
          "updatedAt": "2021-10-22T12:09:31Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Done.",
              "createdAt": "2021-10-22T12:09:31Z",
              "updatedAt": "2021-10-22T12:09:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u5SSE",
          "commit": {
            "abbreviatedOid": "dda25de"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T12:12:40Z",
          "updatedAt": "2021-10-22T12:12:40Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Done.",
              "createdAt": "2021-10-22T12:12:40Z",
              "updatedAt": "2021-10-22T12:12:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u5STf",
          "commit": {
            "abbreviatedOid": "dda25de"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T12:12:47Z",
          "updatedAt": "2021-10-22T12:12:47Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Done.",
              "createdAt": "2021-10-22T12:12:47Z",
              "updatedAt": "2021-10-22T12:12:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u7ah-",
          "commit": {
            "abbreviatedOid": "f319d38"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Merging as-is and will iterate on it over the weekend.",
          "createdAt": "2021-10-22T23:27:43Z",
          "updatedAt": "2021-10-22T23:27:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOGKuqOc4tnd68",
      "title": "Finish `hits` specification",
      "url": "https://github.com/cjpatton/vdaf/pull/5",
      "state": "MERGED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-25T10:33:46Z",
      "updatedAt": "2021-10-25T15:56:06Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "a17f7917cbf554c3c50464252c371286561a9040",
      "headRepository": "cjpatton/vdaf",
      "headRefName": "vdaf_hits",
      "headRefOid": "76f086eddda2feba75558d41c381991d873fe17e",
      "closedAt": "2021-10-25T15:55:00Z",
      "mergedAt": "2021-10-25T15:55:00Z",
      "mergedBy": "schoppmp",
      "mergeCommit": {
        "oid": "4ab9d62399dc4b879f592af05cf16c37c0f4eed2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4u-t8t",
          "commit": {
            "abbreviatedOid": "5e545b3"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T14:21:21Z",
          "updatedAt": "2021-10-25T14:32:08Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "No, each aggregator is mean to consume all of the messages sent in the previous round.",
              "createdAt": "2021-10-25T14:21:21Z",
              "updatedAt": "2021-10-25T14:32:08Z"
            },
            {
              "originalPosition": 38,
              "body": "Ack, let's delete my comment then.",
              "createdAt": "2021-10-25T14:22:29Z",
              "updatedAt": "2021-10-25T14:32:08Z"
            },
            {
              "originalPosition": 49,
              "body": "The first is used by the first aggregator and the second is used by the second.",
              "createdAt": "2021-10-25T14:22:57Z",
              "updatedAt": "2021-10-25T14:32:08Z"
            },
            {
              "originalPosition": 61,
              "body": "It does. I went back-and-forth on this and ultimately thought that this is simpler. The reason is that this loop in `run_vdaf` \r\n```\r\n# Aggregators recover their output shares.\r\ninbound = []\r\nfor i in range(ROUNDS+1):\r\n  outbound = []\r\n  for j in range(SHARES):\r\n    outbound.append(eval_states[j].next(inbound))\r\n  inbound = outbound\r\n```\r\n\r\nwould have to be something like\r\n```\r\n# Aggregators recover their output shares.\r\ninbound = []\r\nfor i in range(ROUNDS+1):\r\n  outbound = []\r\n  for j in range(SHARES):\r\n    inbound_for_aggregator = []\r\n    for (k, v) in enumerate(inbound):\r\n      if k != j: inbound_for_aggregator.append(v)\r\n    outbound.append(eval_states[j].next(inbound))\r\n  inbound = outbound\r\n```",
              "createdAt": "2021-10-25T14:30:29Z",
              "updatedAt": "2021-10-25T14:32:08Z"
            },
            {
              "originalPosition": 76,
              "body": "I don't think so, and good catch here. What about passing the aggregation parameter into the constructor here and computing the number of prefixes from that? We'd need to make the same change in the VDAF definition section.",
              "createdAt": "2021-10-25T14:32:00Z",
              "updatedAt": "2021-10-25T14:32:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u-46g",
          "commit": {
            "abbreviatedOid": "5e545b3"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T14:53:21Z",
          "updatedAt": "2021-10-25T14:53:22Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "Changed the definition here.",
              "createdAt": "2021-10-25T14:53:22Z",
              "updatedAt": "2021-10-25T14:53:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u-48u",
          "commit": {
            "abbreviatedOid": "f9fdc26"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T14:53:27Z",
          "updatedAt": "2021-10-25T14:53:28Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Okay, removed my comment.",
              "createdAt": "2021-10-25T14:53:27Z",
              "updatedAt": "2021-10-25T14:53:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u-4-3",
          "commit": {
            "abbreviatedOid": "f9fdc26"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T14:53:33Z",
          "updatedAt": "2021-10-25T14:53:33Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Ack. Removed the comment.",
              "createdAt": "2021-10-25T14:53:33Z",
              "updatedAt": "2021-10-25T14:53:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u-5A2",
          "commit": {
            "abbreviatedOid": "f9fdc26"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T14:53:38Z",
          "updatedAt": "2021-10-25T14:53:39Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Done.",
              "createdAt": "2021-10-25T14:53:38Z",
              "updatedAt": "2021-10-25T14:53:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u-5Kx",
          "commit": {
            "abbreviatedOid": "f9fdc26"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T14:54:07Z",
          "updatedAt": "2021-10-25T14:54:07Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Ack. Removed comment.",
              "createdAt": "2021-10-25T14:54:07Z",
              "updatedAt": "2021-10-25T14:54:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u-6P9",
          "commit": {
            "abbreviatedOid": "962a327"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T14:57:18Z",
          "updatedAt": "2021-10-25T14:57:41Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "As we (ideally!) make clear in the Overview/Definition sections, this document doesn't tell you how to execute the protocol over a network. This function in particular only tells you how you put the pieces together to execute the VDAF over a set of inputs.\r\n\r\nTo make an analogy: VDAF is, in this sense, like an encryption scheme. It doesn't tell *how* to encrypt packets that you send over the network, it just describes a function and its intended properties. ",
              "createdAt": "2021-10-25T14:57:18Z",
              "updatedAt": "2021-10-25T14:57:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u-70M",
          "commit": {
            "abbreviatedOid": "962a327"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T15:01:52Z",
          "updatedAt": "2021-10-25T15:11:55Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "I found this necessary when I did my implemnetation. The reason is that the `verifier_share` is supposed to be a 2-way additive share.",
              "createdAt": "2021-10-25T15:01:52Z",
              "updatedAt": "2021-10-25T15:11:55Z"
            },
            {
              "originalPosition": 47,
              "body": "Resolution: have one party add the first term.",
              "createdAt": "2021-10-25T15:11:52Z",
              "updatedAt": "2021-10-25T15:11:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u_IWT",
          "commit": {
            "abbreviatedOid": "1f0adbf"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T15:41:52Z",
          "updatedAt": "2021-10-25T15:41:52Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Okay. Changed the comment to clarify where the network communication would take place.",
              "createdAt": "2021-10-25T15:41:52Z",
              "updatedAt": "2021-10-25T15:41:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u_IZK",
          "commit": {
            "abbreviatedOid": "1f0adbf"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T15:42:01Z",
          "updatedAt": "2021-10-25T15:42:02Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Done.",
              "createdAt": "2021-10-25T15:42:02Z",
              "updatedAt": "2021-10-25T15:42:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u_Js9",
          "commit": {
            "abbreviatedOid": "1f0adbf"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-25T15:46:32Z",
          "updatedAt": "2021-10-25T15:46:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 6,
      "id": "PR_kwDOGKuqOc4toxx7",
      "title": "Update authors",
      "url": "https://github.com/cjpatton/vdaf/pull/6",
      "state": "MERGED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-25T16:57:11Z",
      "updatedAt": "2021-10-25T17:00:39Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "8d6bc15ea63c534a8398985fbacaf7acc1aad9a9",
      "headRepository": "cjpatton/vdaf",
      "headRefName": "update_authors",
      "headRefOid": "a3e13b02617094cee91ba6a8ef9e3d13724a6ffe",
      "closedAt": "2021-10-25T17:00:39Z",
      "mergedAt": "2021-10-25T17:00:39Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "ee05d18c5cd217354acfa713e0fec79aeec61330"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4u_dkr",
          "commit": {
            "abbreviatedOid": "a3e13b0"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-25T17:00:29Z",
          "updatedAt": "2021-10-25T17:00:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 7,
      "id": "PR_kwDOGKuqOc4tpN7W",
      "title": "RLB refactor of vdaf",
      "url": "https://github.com/cjpatton/vdaf/pull/7",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-25T19:35:28Z",
      "updatedAt": "2021-10-25T22:26:37Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "d8059ea57a2d09fbd21842dd297c735584c35887",
      "headRepository": "cjpatton/vdaf",
      "headRefName": "vdaf-refactor",
      "headRefOid": "a96d3c3b163c955abeb56671fc8f1c8ca3aa239f",
      "closedAt": "2021-10-25T20:54:52Z",
      "mergedAt": "2021-10-25T20:54:52Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "29a8ff25572bd9fc4ba400100c1e58332b6e32b3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4vACJz",
          "commit": {
            "abbreviatedOid": "94b96e1"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-25T19:40:51Z",
          "updatedAt": "2021-10-25T20:52:38Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Caption needs updating.",
              "createdAt": "2021-10-25T19:40:51Z",
              "updatedAt": "2021-10-25T20:52:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4vAjVp",
          "commit": {
            "abbreviatedOid": "a96d3c3"
          },
          "author": "ekr",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T22:23:01Z",
          "updatedAt": "2021-10-25T22:26:37Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I don't love this term. Maybe \"Decoding\"?",
              "createdAt": "2021-10-25T22:23:02Z",
              "updatedAt": "2021-10-25T22:26:37Z"
            },
            {
              "originalPosition": 50,
              "body": "Do we need to assume it's randomized?",
              "createdAt": "2021-10-25T22:24:15Z",
              "updatedAt": "2021-10-25T22:26:37Z"
            },
            {
              "originalPosition": 56,
              "body": "Is this always true? Suppose we had a VDAF in which the ZKPs of correctness were publicly verifiable?",
              "createdAt": "2021-10-25T22:25:16Z",
              "updatedAt": "2021-10-25T22:26:37Z"
            },
            {
              "originalPosition": 90,
              "body": "This seems like an unnecessary assumption. It might be true, but it might not be.",
              "createdAt": "2021-10-25T22:26:06Z",
              "updatedAt": "2021-10-25T22:26:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOGKuqOc4wWGea",
      "title": "Add public preprocessing of messages",
      "url": "https://github.com/cjpatton/vdaf/pull/14",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #11.\r\n\r\nThis makes explicit a feature of prio3 and hits that allows applications\r\nto save on bandwidth. At the same time, it does not decrease generality\r\nsince this preprocessing step might simply be a no-op.\r\n\r\nThis change also replaces reference to `vec_zeros()` with\r\n`Field.zeros()`.\r\n",
      "createdAt": "2021-12-28T18:47:12Z",
      "updatedAt": "2022-02-08T16:52:27Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "71f9481b446f191da17118fd4b82b1a8cf9aa6fd",
      "headRepository": "cjpatton/vdaf",
      "headRefName": "cjpatton/issue11",
      "headRefOid": "bd8b7a4a80336d15980164b1afe731c17bc1f3a2",
      "closedAt": "2022-01-19T17:44:44Z",
      "mergedAt": "2022-01-19T17:44:43Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "6b856956b14b89d70e22ed8fd3655f9521720b14"
      },
      "comments": [
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It seems like this PR is just splitting `next` into two steps that both happen inside the same computer. Why is this useful?\r\n> \r\n> In general, I think the design philosophy should be that the inputs and outputs from these abstract functions should be to the network, i.e., the boundaries that matter are the ones that are visible from the outside. How the processing is arranged inside the computer, between network-observable points, is up to the individual implementation.\r\n\r\nThe idea is that the leader can do the `prep_preprocess` step once and broadcast the result to however many helpers there are, whereas previously, every aggregator would have had to broadcast prep messages to every other aggregator (extra network communication) and then every aggregator would have to run the prep message assembly (extra CPU time). The reduction in network communication is a much more significant win than the reduction of redundant work, but the it's hard to see that communication graph in this specification, because it's all abstracted away behind the `inputs = outputs` step, which in a real deployment would be a big, messy graph with `n^2` edges in it.",
          "createdAt": "2022-01-06T18:40:17Z",
          "updatedAt": "2022-01-06T18:40:17Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "With the current syntax:  In a Leader/Helper communication model, the Leader would request each Helper's next prepare message in one round, then broadcast the entire round of messages to each Helper in the next round.\r\n\r\nWith the changed syntax: Instead of broadcasting all of the messages, the Leader can perform this precomputation step, which for both `prio3` and `poplar1` reduces the amount of data broadcast by a factor of `SHARES`.",
          "createdAt": "2022-01-06T22:28:39Z",
          "updatedAt": "2022-01-06T22:28:39Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "I'm going to make an executive decision and merge this by Wednesday, 2022/01/19 unless anyone flags objections to this change. ",
          "createdAt": "2022-01-15T00:27:00Z",
          "updatedAt": "2022-01-15T00:27:00Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm OK with this, as long as we agree that the degenerate case where `prep_shares_to_prep` just concatenates the shares is in-bounds (which puts us back in the broadcast posture).",
          "createdAt": "2022-01-18T22:03:51Z",
          "updatedAt": "2022-01-18T22:04:18Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "> I'm OK with this, as long as we agree that the degenerate case where `prep_shares_to_prep` just concatenates the shares is in-bounds (which puts us back in the broadcast posture).\r\n\r\nYeah I agree. It would be premature to rule this out.",
          "createdAt": "2022-01-19T00:29:16Z",
          "updatedAt": "2022-01-19T00:29:16Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "Squashed. Thanks all for your feedback!",
          "createdAt": "2022-01-19T17:44:29Z",
          "updatedAt": "2022-01-19T17:44:29Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4yIVrb",
          "commit": {
            "abbreviatedOid": "cc28349"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-28T18:48:16Z",
          "updatedAt": "2021-12-28T18:48:16Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Can we think of a better verb than \"preprocess\"? While accurate, it seems too generic.",
              "createdAt": "2021-12-28T18:48:16Z",
              "updatedAt": "2021-12-28T18:48:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yT1lW",
          "commit": {
            "abbreviatedOid": "aa4ebef"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-04T22:25:32Z",
          "updatedAt": "2022-01-05T01:48:26Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Should this be `Optional[Vec[Bytes]]` or is `Bytes` itself a vector of bytes? ",
              "createdAt": "2022-01-04T22:25:32Z",
              "updatedAt": "2022-01-05T01:48:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yUNLA",
          "commit": {
            "abbreviatedOid": "aa4ebef"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-05T02:05:32Z",
          "updatedAt": "2022-01-05T02:05:32Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "`Bytes` is itself a vector of bytes.",
              "createdAt": "2022-01-05T02:05:32Z",
              "updatedAt": "2022-01-05T02:05:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yZl0N",
          "commit": {
            "abbreviatedOid": "aa4ebef"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-06T12:16:36Z",
          "updatedAt": "2022-01-06T12:19:04Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Can you elaborate a bit what the `prep_preprocess` step does and in what cases it is useful? This doesn't become clear from the description currently.",
              "createdAt": "2022-01-06T12:16:36Z",
              "updatedAt": "2022-01-06T12:19:04Z"
            },
            {
              "originalPosition": 29,
              "body": "I agree, in particular the double `pre` prefix is a bit confusing. Maybe `combine_verifier_shares` or something like that?",
              "createdAt": "2022-01-06T12:18:49Z",
              "updatedAt": "2022-01-06T12:19:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4ya-93",
          "commit": {
            "abbreviatedOid": "aa4ebef"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "It seems like this PR is just splitting `next` into two steps that both happen inside the same computer.  Why is this useful?\r\n\r\nIn general, I think the design philosophy should be that the inputs and outputs from these abstract functions should be to the network, i.e., the boundaries that matter are the ones that are visible from the outside.  How the processing is arranged inside the computer, between network-observable points, is up to the individual implementation.",
          "createdAt": "2022-01-06T18:33:55Z",
          "updatedAt": "2022-01-06T18:33:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc4yb1Kk",
          "commit": {
            "abbreviatedOid": "5b0720b"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-06T23:18:57Z",
          "updatedAt": "2022-01-06T23:18:58Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I like the term `verifier_share`, but it's somewhat specific to schemes like `prio3` and `poplar1` where the output share are first recovered and then verified. At this stage I'd like to leave the door open for things like Prio+ that are based instead on oblivious transfer. (Output shares aren't known until the prep phase is complete.)",
              "createdAt": "2022-01-06T23:18:58Z",
              "updatedAt": "2022-01-06T23:18:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yb1Xm",
          "commit": {
            "abbreviatedOid": "5b0720b"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-06T23:20:42Z",
          "updatedAt": "2022-01-06T23:20:42Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I went with \"prepare-message share\", which is overly wordy but says what we want. The method is now called `prep_share_to_prep`, which is somewhat consistent with our naming conventions else where. \r\n\r\nOther suggestions for alternatives are welcome! (Naming things is hard.) ",
              "createdAt": "2022-01-06T23:20:42Z",
              "updatedAt": "2022-01-06T23:20:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yb1ZF",
          "commit": {
            "abbreviatedOid": "5b0720b"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-06T23:20:55Z",
          "updatedAt": "2022-01-06T23:20:55Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I've tacked on a commit that will hopefully make this more clear.",
              "createdAt": "2022-01-06T23:20:55Z",
              "updatedAt": "2022-01-06T23:20:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4y7LBX",
          "commit": {
            "abbreviatedOid": "176ab24"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-17T13:05:33Z",
          "updatedAt": "2022-01-17T13:09:35Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "`transffer` -> `transfer`",
              "createdAt": "2022-01-17T13:05:34Z",
              "updatedAt": "2022-01-17T13:09:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4zAkR7",
          "commit": {
            "abbreviatedOid": "6de0c44"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-18T17:57:39Z",
          "updatedAt": "2022-01-18T17:57:39Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "Done",
              "createdAt": "2022-01-18T17:57:39Z",
              "updatedAt": "2022-01-18T17:57:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDOGKuqOc4wiAdr",
      "title": "Rename \"Heavy Hitters\" to \"Poplar\"",
      "url": "https://github.com/cjpatton/vdaf/pull/16",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The authors of [BBCGGI21] have recently amended their paper to give the\r\nprotocol a proper name.",
      "createdAt": "2022-01-04T21:41:01Z",
      "updatedAt": "2022-02-08T16:52:26Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "84e7b02d3474c2a6fcf79de1c79abacec4d0303f",
      "headRepository": "cjpatton/vdaf",
      "headRefName": "cjpatton/poplar",
      "headRefOid": "5b961d3a0192626bfc66a2ef97b24bb054283cf9",
      "closedAt": "2022-01-06T18:31:40Z",
      "mergedAt": "2022-01-06T18:31:40Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "082a2ed7e5090d2258be98039d51b10f7532900c"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "s/pops/poplar1",
          "createdAt": "2022-01-06T18:31:15Z",
          "updatedAt": "2022-01-06T18:31:15Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4yTwIQ",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-04T21:51:28Z",
          "updatedAt": "2022-01-04T21:51:52Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I would just call this `poplar`, since we just use `prio` for Prio.",
              "createdAt": "2022-01-04T21:51:28Z",
              "updatedAt": "2022-01-04T21:51:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yTwgh",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-04T21:53:40Z",
          "updatedAt": "2022-01-04T21:53:40Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "In fact we use `prio3` for Prio, so it's not even like there's a 4-letter code convention.",
              "createdAt": "2022-01-04T21:53:40Z",
              "updatedAt": "2022-01-04T21:53:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yTwnd",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-04T21:54:18Z",
          "updatedAt": "2022-01-04T21:54:19Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "It's tricky because the full-blown heavy hitters protocol is called \"Poplar\". I wanted a distinct name for the underlying VDAF. \"pops\" is the name that @henrycg and I discussed over email.",
              "createdAt": "2022-01-04T21:54:18Z",
              "updatedAt": "2022-01-04T21:54:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yTxF9",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-04T21:57:09Z",
          "updatedAt": "2022-01-04T21:57:09Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "We could go with something more verbose, like \"poplar-vdaf\".",
              "createdAt": "2022-01-04T21:57:09Z",
              "updatedAt": "2022-01-04T21:57:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yT4NJ",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-04T22:41:38Z",
          "updatedAt": "2022-01-04T22:41:38Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I prefer `poplar` but I'm happy to defer to you as the author here.",
              "createdAt": "2022-01-04T22:41:38Z",
              "updatedAt": "2022-01-04T22:41:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yT4OR",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-04T22:41:46Z",
          "updatedAt": "2022-01-04T22:41:46Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc4yT7nH",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-04T23:07:14Z",
          "updatedAt": "2022-01-04T23:07:14Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I'd like to give folks a chance to mull on it, so we''ll keep this open for now.",
              "createdAt": "2022-01-04T23:07:14Z",
              "updatedAt": "2022-01-04T23:07:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yZnxO",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-06T12:27:42Z",
          "updatedAt": "2022-01-06T12:28:54Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I'm not sure about `pops`, at first it looks like it's an acronym, but it isn't. I don't think using `poplar` for both the end-to-end protocol and the VDAF is too much of an issue. Or @cjpatton do you think there will be instantiations of poplar-the-protocol that use a different VDAF? And in that case, couldn't that VDAF be called `poplar2` (the same way the current Prio VDAF is `prio3`?\r\nAlternatively, I think using `poplar-vdaf` (and also changing `prio3` to `prio3-vdaf` or just `prio-vdaf`) is also fine.",
              "createdAt": "2022-01-06T12:27:42Z",
              "updatedAt": "2022-01-06T12:28:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4ya-PU",
          "commit": {
            "abbreviatedOid": "5b961d3"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-06T18:30:28Z",
          "updatedAt": "2022-01-06T18:30:28Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Cool, one more point of agreement :) As discussed in https://github.com/abetterinternet/ppm-specification/pull/177#discussion_r778413433 we're going with `poplar1`, for the same reason you point out.",
              "createdAt": "2022-01-06T18:30:28Z",
              "updatedAt": "2022-01-06T18:30:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 17,
      "id": "PR_kwDOGKuqOc4wiH08",
      "title": "fix typos",
      "url": "https://github.com/cjpatton/vdaf/pull/17",
      "state": "MERGED",
      "author": "tgeoghegan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fix typos encountered while reviewing #14",
      "createdAt": "2022-01-04T22:40:50Z",
      "updatedAt": "2022-01-04T23:03:23Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "2c85aaa13d93b9105bb4139ce501aa9f6dcbdd1b",
      "headRepository": "tgeoghegan/vdaf",
      "headRefName": "typo",
      "headRefOid": "c269414d533f4a20f91d6aca9f25a482e79eacae",
      "closedAt": "2022-01-04T23:03:23Z",
      "mergedAt": "2022-01-04T23:03:23Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "84e7b02d3474c2a6fcf79de1c79abacec4d0303f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4yT7If",
          "commit": {
            "abbreviatedOid": "c269414"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-04T23:03:16Z",
          "updatedAt": "2022-01-04T23:03:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 21,
      "id": "PR_kwDOGKuqOc4x1Ntz",
      "title": "Make re-generation of `verify_params` RECOMMENDED",
      "url": "https://github.com/cjpatton/vdaf/pull/21",
      "state": "MERGED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed in #18, generating `verify_params` in advance may allow an adversary to break correctness if they can corrupt an aggregation server (passively) and a client (actively). This change recommends generating `verify_params` only after a set of client shares has been fixed.",
      "createdAt": "2022-01-31T11:28:30Z",
      "updatedAt": "2022-02-04T15:22:50Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "6b856956b14b89d70e22ed8fd3655f9521720b14",
      "headRepository": "cjpatton/vdaf",
      "headRefName": "regenerate_verify_params",
      "headRefOid": "1f0e87e6161fe5aa02f7945627ae06affc2982f8",
      "closedAt": "2022-02-04T15:22:50Z",
      "mergedAt": "2022-02-04T15:22:49Z",
      "mergedBy": "schoppmp",
      "mergeCommit": {
        "oid": "0412bc0b85f6f35bc510543840ba1a54aa9bfb35"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4zwKNl",
          "commit": {
            "abbreviatedOid": "d29f39c"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-31T18:32:32Z",
          "updatedAt": "2022-01-31T18:32:37Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I'd prefer this text to be in security considerations, along with a short explanation of the threat model being considered.",
              "createdAt": "2022-01-31T18:32:33Z",
              "updatedAt": "2022-01-31T18:32:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4z6ess",
          "commit": {
            "abbreviatedOid": "1f0e87e"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-02T18:42:35Z",
          "updatedAt": "2022-02-02T18:42:35Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Done.",
              "createdAt": "2022-02-02T18:42:35Z",
              "updatedAt": "2022-02-02T18:42:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4z_lBN",
          "commit": {
            "abbreviatedOid": "1f0e87e"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Perfect, thanks!",
          "createdAt": "2022-02-03T19:17:14Z",
          "updatedAt": "2022-02-03T19:17:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 23,
      "id": "PR_kwDOGKuqOc4x_qJm",
      "title": "prio3 reference implementation (part 1)",
      "url": "https://github.com/cjpatton/vdaf/pull/23",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-02T22:54:17Z",
      "updatedAt": "2022-02-03T02:30:38Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "6b856956b14b89d70e22ed8fd3655f9521720b14",
      "headRepository": "cjpatton/vdaf",
      "headRefName": "cjpatton/prio3-wrapper",
      "headRefOid": "1bc6e937680767f7aa7075ac389c624c1899ecd5",
      "closedAt": "2022-02-03T02:30:38Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 24,
      "id": "PR_kwDOGKuqOc4yAQaA",
      "title": "poc: Wrapper bits for prio3",
      "url": "https://github.com/cjpatton/vdaf/pull/24",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-03T04:55:32Z",
      "updatedAt": "2022-02-08T22:16:46Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "5da19ba913c82e3b8c9a4d0cdeaa5fcf6309f778",
      "headRepository": "cjpatton/vdaf",
      "headRefName": "cjpatton/prio3-wrapper",
      "headRefOid": "6d2f6fa590e0ecabaf9825f3aa6f4f086714c9c3",
      "closedAt": "2022-02-08T22:16:39Z",
      "mergedAt": "2022-02-08T22:16:39Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "181607612619efcab9115c5572ec523d364f0a5b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 25,
      "id": "PR_kwDOGKuqOc4yNMJN",
      "title": "Specify a method for deriving pseudorandom field elements",
      "url": "https://github.com/cjpatton/vdaf/pull/25",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #13.",
      "createdAt": "2022-02-08T01:15:41Z",
      "updatedAt": "2022-02-14T20:28:15Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "d5baf89e87695569f4dbf8d79d9e008fcfc9e79c",
      "headRepository": "cjpatton/vdaf",
      "headRefName": "cjpatton/prg",
      "headRefOid": "24998534b894de7a5aeca6bd7764a81608384225",
      "closedAt": "2022-02-14T20:28:15Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "Re-opening this PR with a new base.",
          "createdAt": "2022-02-14T20:28:15Z",
          "updatedAt": "2022-02-14T20:28:15Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 26,
      "id": "PR_kwDOGKuqOc4yRjBk",
      "title": "prio3: Don't generate joint randomness if JOINT_RAND_LEN == 0",
      "url": "https://github.com/cjpatton/vdaf/pull/26",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #15.",
      "createdAt": "2022-02-09T03:58:04Z",
      "updatedAt": "2022-02-09T04:35:53Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "0ed776f687b2592820af150416a30ed16dbab7da",
      "headRepository": "cjpatton/vdaf",
      "headRefName": "cjpatton/joint-rand-len",
      "headRefOid": "94a9986bc29be2455f998dd60eec9091186fbf03",
      "closedAt": "2022-02-09T04:35:39Z",
      "mergedAt": "2022-02-09T04:35:39Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "5de2062ac1f1524a9ce8e23c08a24938c5f32fc1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 27,
      "id": "PR_kwDOGKuqOc4ydh-y",
      "title": "prio3: Specify the generic FLP",
      "url": "https://github.com/cjpatton/vdaf/pull/27",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Specification of the \"generic FLP\", an extension of Theorem 4.3 from [BBCGGI19]. This proof system is implemented by https://github.com/abetterinternet/libprio-rs/blob/main/src/pcp.rs.\r\n\r\n2022/2/10: This PR is marked as \"draft\" for now, as it'll need a few more clean-up passes before it's ready to merge. I wanted to have something up early so @chris-wood has something to work off of for the reference implementation.\r\n2022/23/14: Ready to merge.",
      "createdAt": "2022-02-11T02:25:06Z",
      "updatedAt": "2022-02-25T19:40:13Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "d8cf35917ab6556cc5e7514a05569136fad23d1e",
      "headRepository": "cjpatton/vdaf",
      "headRefName": "cjpatton/flp",
      "headRefOid": "bea5fd53554b10103a8ec92e4ebe1b820d6dd41c",
      "closedAt": "2022-02-25T19:40:13Z",
      "mergedAt": "2022-02-25T19:40:13Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "58d3bf725cbf33c83667f14f1d83746bbaf13fab"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc40_UD0",
          "commit": {
            "abbreviatedOid": "4b80527"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-21T18:38:43Z",
          "updatedAt": "2022-02-25T17:40:54Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Is this really a requirement, or simply something that's nice to have?",
              "createdAt": "2022-02-21T18:38:43Z",
              "updatedAt": "2022-02-25T17:40:54Z"
            },
            {
              "originalPosition": 129,
              "body": "```suggestion\r\nover the input. For VDAFs, this computation is distributed amongst multiple Aggregators, \r\neach of which has only a share of the input.\r\n```",
              "createdAt": "2022-02-21T18:42:49Z",
              "updatedAt": "2022-02-25T17:40:54Z"
            },
            {
              "originalPosition": 191,
              "body": "I'd hint at how these are fixed (for FFT friendliness) somehow.",
              "createdAt": "2022-02-21T18:57:55Z",
              "updatedAt": "2022-02-25T17:40:54Z"
            },
            {
              "originalPosition": 282,
              "body": "I wouldn't use the term arity in this document, even if it's technically correct. I would use something simpler, i.e., the gadgets input counts. ",
              "createdAt": "2022-02-21T19:07:59Z",
              "updatedAt": "2022-02-25T17:40:54Z"
            },
            {
              "originalPosition": 358,
              "body": "```suggestion\r\n1. For each `G` in `Valid.GADGETS` create an empty table `wire_i`.\r\n```",
              "createdAt": "2022-02-21T19:32:15Z",
              "updatedAt": "2022-02-25T17:40:54Z"
            },
            {
              "originalPosition": 331,
              "body": "```suggestion\r\n* For each `i` in `len(Valid.GADGETS)`:\r\n```",
              "createdAt": "2022-02-21T19:35:10Z",
              "updatedAt": "2022-02-25T17:40:54Z"
            },
            {
              "originalPosition": 336,
              "body": "```suggestion\r\n    * Let `alpha_i = Field.gen()^(Field.GEN_ORDER / P_i)`\r\n```",
              "createdAt": "2022-02-21T19:35:20Z",
              "updatedAt": "2022-02-25T17:40:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41Sivj",
          "commit": {
            "abbreviatedOid": "1e8ee51"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:00:54Z",
          "updatedAt": "2022-02-25T19:00:55Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "As noted here, this is required for the generic FLP construction, in particular because it uses the group generator to pick the points used to construct the gadget polynomials. It would be possible to pick these points differently, but that would be a different construction.\r\n\r\nAnother option is to make these fixed points a parameter. I see no reason to do this, however.",
              "createdAt": "2022-02-25T19:00:55Z",
              "updatedAt": "2022-02-25T19:00:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41SjHt",
          "commit": {
            "abbreviatedOid": "1e8ee51"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:02:17Z",
          "updatedAt": "2022-02-25T19:02:17Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "Done",
              "createdAt": "2022-02-25T19:02:17Z",
              "updatedAt": "2022-02-25T19:02:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41Sj78",
          "commit": {
            "abbreviatedOid": "1e8ee51"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:06:06Z",
          "updatedAt": "2022-02-25T19:06:06Z",
          "comments": [
            {
              "originalPosition": 191,
              "body": "Done",
              "createdAt": "2022-02-25T19:06:06Z",
              "updatedAt": "2022-02-25T19:06:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41Sj_a",
          "commit": {
            "abbreviatedOid": "1e8ee51"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:06:22Z",
          "updatedAt": "2022-02-25T19:06:23Z",
          "comments": [
            {
              "originalPosition": 282,
              "body": "Ack",
              "createdAt": "2022-02-25T19:06:23Z",
              "updatedAt": "2022-02-25T19:06:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41SkBt",
          "commit": {
            "abbreviatedOid": "1e8ee51"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:06:31Z",
          "updatedAt": "2022-02-25T19:06:31Z",
          "comments": [
            {
              "originalPosition": 358,
              "body": "Ack",
              "createdAt": "2022-02-25T19:06:31Z",
              "updatedAt": "2022-02-25T19:06:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41SkDe",
          "commit": {
            "abbreviatedOid": "1e8ee51"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:06:39Z",
          "updatedAt": "2022-02-25T19:06:39Z",
          "comments": [
            {
              "originalPosition": 331,
              "body": "Ack",
              "createdAt": "2022-02-25T19:06:39Z",
              "updatedAt": "2022-02-25T19:06:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41SkFo",
          "commit": {
            "abbreviatedOid": "1e8ee51"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:06:48Z",
          "updatedAt": "2022-02-25T19:06:48Z",
          "comments": [
            {
              "originalPosition": 336,
              "body": "Done",
              "createdAt": "2022-02-25T19:06:48Z",
              "updatedAt": "2022-02-25T19:06:48Z"
            }
          ]
        }
      ]
    },
    {
      "number": 28,
      "id": "PR_kwDOGKuqOc4y0Ao1",
      "title": "Specify an instantiation of `Prg`",
      "url": "https://github.com/cjpatton/vdaf/pull/28",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Specifies a construction based on AES128. While pretty straight-forward,\r\nthis scheme uses CMAC, which is not widely used. We may want to provide\r\nadditional options in the future.",
      "createdAt": "2022-02-14T20:33:31Z",
      "updatedAt": "2022-02-28T16:07:43Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "582c3a58e8c9a8c6c9fb1763b52ed4de98b3d248",
      "headRepository": "cjpatton/vdaf",
      "headRefName": "cjpatton/prg-constructions",
      "headRefOid": "33d5930607a3853cb701e768314ec7f27fda2e76",
      "closedAt": "2022-02-28T16:07:42Z",
      "mergedAt": "2022-02-28T16:07:42Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "5b832679851002485c004c461948491837624102"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "> This will likely be called often, but with small `length`s, right? In that case I believe constructions based on [fixed-key AES hashing](https://eprint.iacr.org/2019/074.pdf) should be more efficient, since they avoid repeating the AES key schedule. In the paper there is a tweakable version (using two AES calls) that can be used to derive new seeds for different `info` strings.\r\n\r\nGreat question. There are two key schedules:\r\n* One for CMAC. The same key is used for each blockcipher call, including for generating the subkey K1 (or K2, depending on the length of the message.) See https://datatracker.ietf.org/doc/html/rfc4493#section-2.2.\r\n* One for CTR.\r\n\r\nEventually the cumulative cost of AES costs will outstrip the cost of the initial setup of these two key schedules, so the question is whether we reach this point in our code. There are at least two cases to consider: \r\n1. In #31, each `length` passed to `prg.next()` is small, but we call `prg.next()` many times. Hence the computational cost will be dominated in `AES128-CTR()`.\r\n2. In prio3, we use `Prg.derive()` as a PRF. Here the input is long (though not as long as in (1.)), but the output is short. Hence the computational cost will be dominated by `AES128-CMAC()`.\r\n\r\nMy hunch is that we cross this threshold fairly quickly for (1.), but I'm not so sure about (2.). I think this is something worth benchmarking in any case.\r\n\r\nI suggest we put a pin in this for now. I'll mark this is an \"OPEN ISSUE\" in the text and we can open an issue for tracking benchmarking of various PRGs.\r\n\r\n\r\n",
          "createdAt": "2022-02-25T19:38:12Z",
          "updatedAt": "2022-02-25T19:38:12Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "I've added a pointer to https://github.com/cjpatton/vdaf/issues/32 to the text.",
          "createdAt": "2022-02-25T19:50:52Z",
          "updatedAt": "2022-02-25T19:50:52Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> I suggest we put a pin in this for now. I'll mark this is an \"OPEN ISSUE\" in the text and we can open an issue for tracking benchmarking of various PRGs.\r\n\r\nSounds good, thanks!",
          "createdAt": "2022-02-28T11:33:20Z",
          "updatedAt": "2022-02-28T11:33:20Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc40lRkI",
          "commit": {
            "abbreviatedOid": "7b4e1f9"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-14T21:05:30Z",
          "updatedAt": "2022-02-14T21:07:15Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\ngenerating the output. A fixed initialization vector (IV) is used.\r\n```",
              "createdAt": "2022-02-14T21:05:30Z",
              "updatedAt": "2022-02-14T21:07:15Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\n    # a fixed, all-zero IV.\r\n```",
              "createdAt": "2022-02-14T21:05:55Z",
              "updatedAt": "2022-02-14T21:07:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41SkO8",
          "commit": {
            "abbreviatedOid": "9c80897"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This will likely be called often, but with small `length`s, right? In that case I believe constructions based on [fixed-key AES hashing](https://eprint.iacr.org/2019/074.pdf) should be more efficient, since they avoid repeating the AES key schedule. In the paper there is a tweakable version (using two AES calls) that can be used to derive new seeds for different `info` strings.",
          "createdAt": "2022-02-25T19:07:29Z",
          "updatedAt": "2022-02-25T19:07:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc41WDWq",
          "commit": {
            "abbreviatedOid": "33d5930"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-28T11:33:30Z",
          "updatedAt": "2022-02-28T11:33:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 29,
      "id": "PR_kwDOGKuqOc4y0B4C",
      "title": "Use \"pad-then-reduce\" method for generating field elements",
      "url": "https://github.com/cjpatton/vdaf/pull/29",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #13 by taking @armfazh' suggestion.\r\n\r\nSpecifies an algorithm for mapping a pseudorandom byte string to a\r\nvector of field elements. This method is based on the \"hash_to_field\"\r\nalgorithm from draft-irtf-cfrg-hash-to-curve-13.",
      "createdAt": "2022-02-14T20:39:05Z",
      "updatedAt": "2022-02-25T16:13:09Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "d8cf35917ab6556cc5e7514a05569136fad23d1e",
      "headRepository": "cjpatton/vdaf",
      "headRefName": "cjpatton/field-elem-gen-1",
      "headRefOid": "159d7a217560682d1a2c249fe5c89b555014dfeb",
      "closedAt": "2022-02-25T16:13:08Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "Closed in favor of #31.\r\n",
          "createdAt": "2022-02-25T16:13:08Z",
          "updatedAt": "2022-02-25T16:13:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc40lUK4",
          "commit": {
            "abbreviatedOid": "6cdf917"
          },
          "author": "armfazh",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T21:17:14Z",
          "updatedAt": "2022-02-14T21:18:13Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "... The second one generates a sequence of field elements from a pseudorandom byte string. Such a generation is based on ...",
              "createdAt": "2022-02-14T21:17:14Z",
              "updatedAt": "2022-02-14T21:18:13Z"
            },
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n  per field element when expanding a seed into a sequence of field elements\r\n```",
              "createdAt": "2022-02-14T21:17:40Z",
              "updatedAt": "2022-02-14T21:18:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc40lWor",
          "commit": {
            "abbreviatedOid": "6cdf917"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T21:28:10Z",
          "updatedAt": "2022-02-14T21:28:11Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Done",
              "createdAt": "2022-02-14T21:28:10Z",
              "updatedAt": "2022-02-14T21:28:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 30,
      "id": "PR_kwDOGKuqOc4y0PEW",
      "title": "Use \"borrow-then-reduce\" method for generating field elements",
      "url": "https://github.com/cjpatton/vdaf/pull/30",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #13 by taking @schoppmp's suggestion.\r\nAlternative to #29.\r\n\r\nSpecifies an algorithm for a mapping pseudorandom byte string to a\r\nvector of field elements. The algorithm was ported from google's IDPF\r\nimplementation.",
      "createdAt": "2022-02-14T21:39:21Z",
      "updatedAt": "2022-02-25T16:12:52Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "d8cf35917ab6556cc5e7514a05569136fad23d1e",
      "headRepository": "cjpatton/vdaf",
      "headRefName": "cjpatton/field-elem-gen-2",
      "headRefOid": "734b67651a3aea4156e840f12bbb1e21e0f0a81b",
      "closedAt": "2022-02-25T16:12:52Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "Closed in favor of #31.",
          "createdAt": "2022-02-25T16:12:52Z",
          "updatedAt": "2022-02-25T16:12:52Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc40la8c",
          "commit": {
            "abbreviatedOid": "734b676"
          },
          "author": "armfazh",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-14T21:46:55Z",
          "updatedAt": "2022-02-14T21:46:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc41Hfoi",
          "commit": {
            "abbreviatedOid": "734b676"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-23T14:25:28Z",
          "updatedAt": "2022-02-23T14:30:04Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "This can be (length-1) * L + P, since the first sample is taken by reducing r directly, and we don't need to \"fill up\" r at the last iteration.",
              "createdAt": "2022-02-23T14:25:28Z",
              "updatedAt": "2022-02-23T14:30:04Z"
            },
            {
              "originalPosition": 40,
              "body": "This reduction mod 2**P is only needed because Python uses BigInt, right? In that case it might be more efficient to first use a mask to zero out the highest L*8 bits of r, and then do the left-shift. That way we'll only ever use P bits.",
              "createdAt": "2022-02-23T14:28:47Z",
              "updatedAt": "2022-02-23T14:30:04Z"
            },
            {
              "originalPosition": 41,
              "body": "As written above, this is not needed in the last iteration, so we can save L random bytes.",
              "createdAt": "2022-02-23T14:29:09Z",
              "updatedAt": "2022-02-23T14:30:04Z"
            },
            {
              "originalPosition": 36,
              "body": "Assuming the constructor doesn't fail when r > Field.MODULUS. Maybe make the modulo reduction explicit here?",
              "createdAt": "2022-02-23T14:29:51Z",
              "updatedAt": "2022-02-23T14:30:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41KhCb",
          "commit": {
            "abbreviatedOid": "734b676"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-24T03:43:14Z",
          "updatedAt": "2022-02-24T03:43:14Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Yup this this is because Python is bigint.",
              "createdAt": "2022-02-24T03:43:14Z",
              "updatedAt": "2022-02-24T03:43:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41KhIU",
          "commit": {
            "abbreviatedOid": "734b676"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-24T03:44:08Z",
          "updatedAt": "2022-02-24T03:44:09Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "The `Field(.)` constructor does the reduction, as documented above. But I think it would make sense to make this explicit.",
              "createdAt": "2022-02-24T03:44:08Z",
              "updatedAt": "2022-02-24T03:44:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41KhJr",
          "commit": {
            "abbreviatedOid": "734b676"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-24T03:44:23Z",
          "updatedAt": "2022-02-24T03:44:23Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Good call! I'll fix if we end up merging.",
              "createdAt": "2022-02-24T03:44:23Z",
              "updatedAt": "2022-02-24T03:44:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 31,
      "id": "PR_kwDOGKuqOc4zcDuH",
      "title": "Use \"rejection sampling\" for generating field elements",
      "url": "https://github.com/cjpatton/vdaf/pull/31",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #13 by doing \"rejection sampling\". This an alternative to #29 and #30.",
      "createdAt": "2022-02-25T00:50:34Z",
      "updatedAt": "2022-02-25T19:42:17Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "58d3bf725cbf33c83667f14f1d83746bbaf13fab",
      "headRepository": "cjpatton/vdaf",
      "headRefName": "cjpatton/prg-rejection-sampling",
      "headRefOid": "d6b3965cc36026bd77a2e4fb2f60853f76e39e5d",
      "closedAt": "2022-02-25T19:42:17Z",
      "mergedAt": "2022-02-25T19:42:16Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "7d74148aa7d2d8b8bfaf0346d0289ee318ed4801"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc41Ral0",
          "commit": {
            "abbreviatedOid": "e995fa5"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T14:41:59Z",
          "updatedAt": "2022-02-25T14:46:19Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Please add some info about what we expect from the output, e.g.\r\n`\r\nThe bytes returned are uniformly pseudorandom when the PRG was constructed with a uniformly random seed.\r\n`",
              "createdAt": "2022-02-25T14:41:59Z",
              "updatedAt": "2022-02-25T14:46:19Z"
            },
            {
              "originalPosition": 31,
              "body": "Can you add some information for why this is needed? Also please add that the seed MUST have high entropy.",
              "createdAt": "2022-02-25T14:44:46Z",
              "updatedAt": "2022-02-25T14:46:19Z"
            },
            {
              "originalPosition": 37,
              "body": "Same as above, please make sure that this is always used in a safe way by requiring that the seed MUST have high entropy and be only used once.",
              "createdAt": "2022-02-25T14:46:12Z",
              "updatedAt": "2022-02-25T14:46:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41Rq8D",
          "commit": {
            "abbreviatedOid": "e995fa5"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T15:31:44Z",
          "updatedAt": "2022-02-25T15:42:27Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Done. I also stipulated that the random seed might be an output of a previous call to the PRG.\r\n\r\n",
              "createdAt": "2022-02-25T15:31:44Z",
              "updatedAt": "2022-02-25T15:42:27Z"
            },
            {
              "originalPosition": 31,
              "body": "The intended usage is explained above:\r\n> Each `Prg` has two derived class methods. The first is used to derive a fresh seed from an existing one.\r\n\r\nIf you want to see this get used, search for `Prg.derive` in the prio3 section.\r\n\r\nHigh entropy ins't going to be sufficient for all PRGs, in particular for those constructed from a pseudorandom permutation (e.g., AES). I stipulated the same requirement for securely generating seeds as above.",
              "createdAt": "2022-02-25T15:38:44Z",
              "updatedAt": "2022-02-25T15:42:27Z"
            },
            {
              "originalPosition": 37,
              "body": "It depends on the PRG construction, but it should be secure to reuse the same seed with different \"info\" strings. That is, the intent of the \"info\" string is to provide domain separation.\r\n\r\nHere I stipulated the same requirements for generating the seed as above.",
              "createdAt": "2022-02-25T15:42:19Z",
              "updatedAt": "2022-02-25T15:42:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41SfHc",
          "commit": {
            "abbreviatedOid": "5f2e71e"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-25T18:44:28Z",
          "updatedAt": "2022-02-25T18:49:29Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "The current documentation sounds good, thanks!",
              "createdAt": "2022-02-25T18:44:29Z",
              "updatedAt": "2022-02-25T18:49:29Z"
            },
            {
              "originalPosition": 28,
              "body": "Maybe add a note about `info` and domain separation?",
              "createdAt": "2022-02-25T18:48:42Z",
              "updatedAt": "2022-02-25T18:49:29Z"
            },
            {
              "originalPosition": 37,
              "body": "Okay, let's maybe add a short sentence on this to the documentation (see comment above).",
              "createdAt": "2022-02-25T18:49:13Z",
              "updatedAt": "2022-02-25T18:49:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41Sq74",
          "commit": {
            "abbreviatedOid": "5f2e71e"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:39:40Z",
          "updatedAt": "2022-02-25T19:39:41Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Done",
              "createdAt": "2022-02-25T19:39:41Z",
              "updatedAt": "2022-02-25T19:39:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 33,
      "id": "PR_kwDOGKuqOc4zfPGd",
      "title": "Acknoweledge Armando",
      "url": "https://github.com/cjpatton/vdaf/pull/33",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-25T21:40:36Z",
      "updatedAt": "2022-02-25T21:56:08Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "7d74148aa7d2d8b8bfaf0346d0289ee318ed4801",
      "headRepository": "cjpatton/vdaf",
      "headRefName": "cjpatton/ack-armando",
      "headRefOid": "636e7ac818170194489b089a42464537c16a59e0",
      "closedAt": "2022-02-25T21:56:07Z",
      "mergedAt": "2022-02-25T21:56:07Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "03f3ac2114e8e728518728d30b6adb9c8902aedc"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 34,
      "id": "PR_kwDOGKuqOc4zvzEs",
      "title": "poc: Implement the generic FLP",
      "url": "https://github.com/cjpatton/vdaf/pull/34",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "fyi/ @chris-wood",
      "createdAt": "2022-03-01T18:50:27Z",
      "updatedAt": "2022-03-01T18:52:08Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "5b832679851002485c004c461948491837624102",
      "headRepository": "cjpatton/vdaf",
      "headRefName": "cjpatton/poc-flp-generic",
      "headRefOid": "8a7f6f9e1ac9c122dfb1d02b588f24302e15b42d",
      "closedAt": "2022-03-01T18:52:08Z",
      "mergedAt": "2022-03-01T18:52:08Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "65cc1df73c94a074e6d651b0e831dfe7af80917d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 35,
      "id": "PR_kwDOGKuqOc4zwmLF",
      "title": "prio3: Add domain separation",
      "url": "https://github.com/cjpatton/vdaf/pull/35",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Bind the derivation of field elements to the document name and the\r\n\"suite\", consisting of the PRG and FLP.",
      "createdAt": "2022-03-01T23:19:35Z",
      "updatedAt": "2022-03-01T23:57:14Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "7d12cac116bcb084c81d0f1ea64eca9f0fa271ba",
      "headRepository": "cjpatton/vdaf",
      "headRefName": "cjpatton/prio3-test-vec",
      "headRefOid": "573b8be2128537d2a09073a8fbca2ba1224fc2e3",
      "closedAt": "2022-03-01T23:57:14Z",
      "mergedAt": "2022-03-01T23:57:14Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "34a51dd9ac5504e03b2bb5c418677bcea7f1238c"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "body": "fyi/ @tgeoghegan ",
          "createdAt": "2022-03-01T23:19:44Z",
          "updatedAt": "2022-03-01T23:19:44Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 36,
      "id": "PR_kwDOGKuqOc4z2cbN",
      "title": "poc: Library compatibility",
      "url": "https://github.com/cjpatton/vdaf/pull/36",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This fixes a couple hiccups I ran into when running the Sage implementation with some older libraries from my distro. (sagemath 9.0-1ubuntu4 and python3-pycryptodome 3.6.1-2build4) I added a fallback to import PyCryptodome from either of its supported names, and added a conversion from `sage.rings.integer.Integer` to `int` in one place. The second change addresses a ctypes error I got from a PyCryptodome call; presumably newer versions of Sage cooperate with ctypes better on type coercion.",
      "createdAt": "2022-03-02T19:46:31Z",
      "updatedAt": "2022-03-02T23:34:15Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "d8fcbfb639dcdeec80ece097e5012b992dade63e",
      "headRepository": "divergentdave/vdaf",
      "headRefName": "poc-library-compatibility",
      "headRefOid": "ab6d5fc2ae36e293d363952dbb36c982b73e348e",
      "closedAt": "2022-03-02T22:56:10Z",
      "mergedAt": "2022-03-02T22:56:10Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "dff2553f17b13b41a39e66509388a2e29c270df9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc41h_EH",
          "commit": {
            "abbreviatedOid": "ab6d5fc"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-02T19:58:19Z",
          "updatedAt": "2022-03-02T19:58:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 37,
      "id": "PR_kwDOGKuqOc4z-2-t",
      "title": "Edits and test vectors",
      "url": "https://github.com/cjpatton/vdaf/pull/37",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-03-05T01:06:59Z",
      "updatedAt": "2022-03-05T01:21:39Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "29840fd017e6dc9103d1fa996475e0ccaa71d222",
      "headRepository": "cjpatton/vdaf",
      "headRefName": "cjpatton/edit-01",
      "headRefOid": "50717f2d973df8279267dff8a1df28f9f5373ebf",
      "closedAt": "2022-03-05T01:21:39Z",
      "mergedAt": "2022-03-05T01:21:39Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "3a2892a558703f66df671f03355d3e65b86e98fd"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 41,
      "id": "PR_kwDOGKuqOc41LJBc",
      "title": "Small fix to prime selection script",
      "url": "https://github.com/cjpatton/vdaf/pull/41",
      "state": "OPEN",
      "author": "divergentdave",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This fixes a small bug in the prime searching script. Previously, it would skip candidate q values, since it decremented q by i, rather than check each `2^(n-k)-i`. In the interest of completeness, we now check each possible value.",
      "createdAt": "2022-03-28T17:58:47Z",
      "updatedAt": "2022-03-29T18:12:57Z",
      "baseRepository": "cjpatton/vdaf",
      "baseRefName": "main",
      "baseRefOid": "d5d51ef9f7e990229ffa4b2fec624634ad398aa6",
      "headRepository": "divergentdave/vdaf",
      "headRefName": "david/prime-search",
      "headRefOid": "784285e500334e1f5cf5769aaa72fc36fb05996b",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc43Iwmv",
          "commit": {
            "abbreviatedOid": "784285e"
          },
          "author": "cjpatton",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Thanks for checking :) Note that there is still time to pick new primes if we so choose.",
          "createdAt": "2022-03-29T18:12:57Z",
          "updatedAt": "2022-03-29T18:12:57Z",
          "comments": []
        }
      ]
    }
  ]
}